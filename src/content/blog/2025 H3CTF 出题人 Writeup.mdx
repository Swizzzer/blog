---
title: 2025 H^3CTF å‡ºé¢˜äºº Writeup
publishDate: 2025-10-15
description: 'æˆ‘ä»¬æ„å¿µåˆä¸€ï¼ğŸ¥·ğŸ¤ğŸ¥·ğŸ¤ğŸ¥·'
heroImage: {src: 'https://pic.swizzer.cc/2025/10/8351e57df6517808e502d19ee0ad69c2.jpg', inferSize: true}
tags: ['CTF', 'Crypto', 'æµå¯†ç ', 'Lattice', 'Misc', 'AI', 'PGD', 'ä¾§ä¿¡é“']
draft: false 
---

import {Spoiler, Collapse, Tabs, TabItem } from 'astro-pure/user'

> å¾ˆæ—©å°±å¹»æƒ³è¿‡ä¸€æ ¡ä¸‰åŒºæä¸ªCTFè”èµ›ï¼Œæ²¡æƒ³åˆ°åœ¨æœ¬éƒ¨Lilacçš„å·å¬ä¸‹ï¼ŒH^3CTFçœŸçš„åŠäº†èµ·æ¥ã€‚

ä½œä¸ºå‡ºé¢˜äººç»™ç¬¬ä¸€å±ŠH3CTFè´¡çŒ®äº†6ä¸ªé¢˜ç›®ï¼ŒåŒ…æ‹¬3ä¸ªCryptoã€2ä¸ªMiscå’Œ1ä¸ªæ¯”è¾ƒMiscçš„Reverseã€‚

<Spoiler>å‰½çªƒäº†ä¸€äº›å›½é™…èµ›çš„é¢˜ç›®ï¼ŒSwizzeråœ¨æ­¤è¡¨ç¤ºå¿æ‚”</Spoiler>

## Crypto
### isoDream

<Tabs>
<TabItem label="chall.py">
```python
from sage.all import GF, EllipticCurve, polygen, PolynomialRing, Zmod
from Crypto.Util.number import getPrime, isPrime, bytes_to_long
import random


def getSafePrime(bits: int) -> int:
  while True:
    p = getPrime(bits - 1)
    q = 2 * p + 1
    if isPrime(q):
      return q


def encrypt(m: int, p: int, exponents: list[int]):
  modulus = p**3
  y = PolynomialRing(Zmod(modulus), "x").quotient("x**3 + x + 1", "y").gen()
  g = 13 * y + 37
  powers = [pow(m, e, modulus) for e in exponents]
  return [g**e for e in powers]


def transform(secret: int):
  while True:
    try:
      p = getSafePrime(384)
      x = polygen(GF(p))
      F = GF(p**2, "i", modulus=x**2 + 1)
      j = F(secret)
      E = EllipticCurve(j=j)
      kerl = E(0).division_points(5)[1:]
      E2 = E.isogeny(random.choice(kerl)).codomain()
      return p, E2.j_invariant()
    except Exception as _:
      continue


if __name__ == "__main__":
  m = bytes_to_long(open("flag.txt", "rb").read().strip())
  p_m, (re, im) = transform(m)
  p = getSafePrime(256)
  pt = int(re + im)

  # fmt:off
  exps = [(getPrime(384) - 1) * p for _ in range(8)] + [getPrime(384) * (p - 1) for _ in range(8)]
  # fmt: on
  ct = encrypt(pt, p, exps)
  print(p_m)
  print(exps)
  print(ct)
```
</TabItem>
</Tabs>
![836e197497a9e1c0bed7155bb427043b.png](https://pic.swizzer.cc/2025/10/836e197497a9e1c0bed7155bb427043b.png)
é¢˜ç›®é¦–å…ˆåœ¨æ‰©åŸŸä¸Šç”Ÿæˆä¸€æ¡jä¸å˜é‡ä¸ºflagçš„æ›²çº¿ï¼Œç„¶åæŠŠè¿™ä¸ªæ›²çº¿çš„**ä¸€ä¸ª5-isogenyçš„é‚»å±…çš„jä¸å˜é‡çš„å®éƒ¨å’Œè™šéƒ¨çš„å’Œ**ä½œä¸ºplaintextï¼Œæœ€åç”Ÿæˆä¸€ç»„æŒ‡æ•°ï¼Œåœ¨ $Zmod(p^3)$ä¸Šå¯¹plaintextåš å½¢å¦‚$g^{{pt}^{e}}$çš„åŠ å¯†ã€‚
è¿™é‡Œå¤šé¡¹å¼å•†ç¯ä¸Šçš„DLPåœ¨è®¡ç®—æ—¶å¯ä»¥é€šè¿‡å¯¹å¤šé¡¹å¼å–companion matrixå†å–è¡Œåˆ—å¼è½¬åŒ–åˆ°ç¯$Zmod(p^3)$ä¸Šçš„DLPï¼Œä¹Ÿå¯ä»¥ç›´æ¥å–èŒƒæ•°è½¬åŒ–ä¸ºç¯$Zmod(p^3)$ä¸Šçš„DLPã€‚
è™½ç„¶è§£å†³$Zmod(p^3)$ä¸Šçš„DLPå¹¶ä¸å®¹æ˜“ï¼Œä½†æ˜¯ç»è¿‡p-adicå¤„ç†ååªéœ€æ±‚æ¨¡é€†å³å¯å¾—åˆ°$Zmod(p^2)$ä¸Šçš„DLPï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ‹¿åˆ°ä¸€ç»„$pt^{e} \pmod{p^2}$ã€‚å› ä¸ºè¿™ç»„eçš„æœ€å¤§å…¬å› å­æ˜¯2,æ‰€ä»¥ç”±bezoutå®šç†å¯ä»¥çŸ¥é“å­˜åœ¨ä¸€ç»„ç³»æ•°$a_{i}$ä½¿å¾— $\sum{a_i}{e_i}=2$ã€‚å¯ä»¥ç”¨LLLæˆ–è€…exgcdæ‰¾åˆ°è¿™æ ·çš„ä¸€ç»„ç³»æ•°ï¼Œä¹‹åå°±èƒ½å¾—åˆ° $pt^2 \pmod{p^2}$
æ¥ä¸‹æ¥ä½¿ç”¨hensel liftingæˆ–æ˜¯å…¶ä»–æ‰‹æ®µæ±‚è§£å‡º$pt$ï¼Œå³å¯å¾—åˆ°**jä¸å˜é‡çš„å®éƒ¨å’Œè™šéƒ¨çš„å’Œã€‚**
æ³¨æ„åˆ°é¢˜ç›®ä¸­çš„èµ·å§‹æ›²çº¿ç»è¿‡ä¸€æ¬¡5-isogenyåå¾—åˆ°çš„æ›²çº¿çš„jä¸å˜é‡æå¤§æ¦‚ç‡è¿˜æ˜¯å®æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥çŒœæµ‹æˆ‘ä»¬å¾—åˆ°çš„å’Œå°±æ˜¯jä¸å˜é‡çš„å®éƒ¨ï¼Œè€Œè™šéƒ¨åˆ™ä¸º0ã€‚è¿™ä¸€ç‚¹ä¹Ÿå¯ä»¥é€šè¿‡æœ¬åœ°æµ‹è¯•éªŒè¯ã€‚
ä¸¤æ¡æ›²çº¿çš„åŒæºå¯ä»¥ç”±modular polynomialè”ç³»èµ·æ¥ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœçŸ¥é“äº†ä¸€ä¸ªjä¸å˜é‡ï¼Œé‚£ä¹ˆå¯ä»¥å°†å…¶ä»£å…¥å¯¹åº”åº¦çš„modular polynomialå»æ±‚æ ¹ï¼Œå¾—åˆ°çš„æ‰€æœ‰æ ¹å°±æ˜¯æ‰€æœ‰ä½œä¸ºä»–çš„é‚»å±…çš„jä¸å˜é‡ã€‚æœ¬é¢˜ä¸­æ˜¯5-isogenyï¼Œå¯ä»¥å» https://math.mit.edu/~drew/modpolys/jfiles/phi_j_5.txt æ‰¾åˆ°å¯¹åº”çš„modular polynomialï¼Œéšåå¯¹è¯¥å¤šé¡¹å¼æ±‚æ ¹å³å¯å¾—åˆ°èµ·å§‹æ›²çº¿çš„jä¸å˜é‡ï¼Œä¹Ÿå°±æ˜¯flagã€‚

<Tabs>
<TabItem label="solve.py">
```python
from sage.all import *
from Crypto.Util.number import GCD, isPrime, long_to_bytes
import ast


# https://pypi.org/project/sageball/
def hensel_solve(f, p, r):
  """
  Solves polynomial roots in the ring Zmod(p**r) using Hensel's lifting method.

  Parameters:
  f (polynomial): The polynomial equation.
  p (int): A prime number.
  r (int): The exponent.

  Raises:
  ValueError: If p is not a prime number or if f has no roots.
  """
  if not is_prime(p):
    raise ValueError("p must be a prime")
  f = f.change_ring(Zp(p))
  F = f.change_ring(Zmod(pow(p, r)))
  P = Zp(p, max(30, r))
  Fd = derivative(F)
  origin_roots = f.roots()
  if not len(origin_roots):
    raise ValueError("f has no roots")
  ans = set()
  for x in origin_roots:
    x_k = ZZ(x[0])
    flag = 0
    for k in range(1, r):
      if Fd(x_k) == P(0):
        if Zmod(pow(p, r))(f(x_k)) == 0:
          continue
        else:
          flag = 1
          break
      else:
        x_k = Zmod(pow(p, r))(P(x_k) - P(F(x_k)) / P(Fd(x_k)))
    if not flag:
      ans.update({x_k})
  return list(ans)


def p_adic_dlp(g, y, p, e):
  R = Zp(p, prec=e)
  x = (R(y).log() / R(g).log()).lift()
  return x


def do_dlog(g, y, p, e, C_f):
  g_ = g.lift().substitute(x=C_f).det()
  y_ = y.lift().substitute(x=C_f).det()
  return p_adic_dlp(g_, y_, p, e)


p_m = eval(open("output.txt").readlines()[0])
exps = eval(open("output.txt").readlines()[1])

p = GCD(*exps[:8]) // 2
assert isPrime(p)
modulus = p**3
PR = PolynomialRing(Zmod(p**3), "x")
x = PR.gen()
f = x**3 + x + 1
y = PR.quotient(f, "y").gen()
ct = eval(open("output.txt").readlines()[-1])
g = 13 * y + 37
C_f = companion_matrix(f)
# replace "^" with "**" before solving
res = []
for y in ct:
  res.append(do_dlog(g, y, p, 3, C_f))
# print(res)
M = identity_matrix(len(res)).augment(vector(exps))
K = 2**128
M[:, -1:] *= K
L = M.LLL()
coeffs = []
for row in L:
  if abs(row[-1] // K) == 2:
    coeffs = row[:-1]
    # print(row)
    break
m = 1
for i in range(len(coeffs)):
  m *= pow(res[i], coeffs[i], p**2)
  m %= p**2
# print(m)

PR2 = PolynomialRing(Zmod(p**2), "z")
z = PR2.gen()
h = z**2 - m
ans = hensel_solve(h, p, 2)
print(ans)
mp5_def_str = """[0,0] 141359947154721358697753474691071362751004672000
[1,0] 53274330803424425450420160273356509151232000
[1,1] -264073457076620596259715790247978782949376
[2,0] 6692500042627997708487149415015068467200
[2,1] 36554736583949629295706472332656640000
[2,2] 5110941777552418083110765199360000
[3,0] 280244777828439527804321565297868800
[3,1] -192457934618928299655108231168000
[3,2] 26898488858380731577417728000
[3,3] -441206965512914835246100
[4,0] 1284733132841424456253440
[4,1] 128541798906828816384000
[4,2] 383083609779811215375
[4,3] 107878928185336800
[4,4] 1665999364600
[5,0] 1963211489280
[5,1] -246683410950
[5,2] 2028551200
[5,3] -4550940
[5,4] 3720
[5,5] -1
[6,0] 1"""
mp5_def = [
  [ast.literal_eval(x) for x in line.split(" ")] for line in mp5_def_str.split("\n")
]
mp_term = (
  lambda e, coef: lambda x, y: coef * x ** e[0] * y ** e[1]
  + coef * x ** e[1] * y ** e[0]
  if e[0] != e[1]
  else coef * x ** e[0] * y ** e[1]
)
mp = lambda mp_def: lambda x, y: sum([mp_term(*term)(x, y) for term in mp_def])
mp5 = mp(mp5_def)
x = var("x")
Fpm = GF(p_m)
Fpm2 = GF(p_m**2, "i", modulus=x**2 + 1)
i = Fpm2.gen()
aa, cc = Fpm2["aa, cc"].gens()
PR_Fpm = Fpm["aa, cc"]
f = mp5(aa + 0 * i, Fpm(int(ans[1])) + 0 * i)
f_real = PR_Fpm(f.map_coefficients(lambda c: c.polynomial()[0])).univariate_polynomial()
for res, _ in f_real.roots():
  if long_to_bytes(int(res)).startswith(b"H3CTF"):
    print(long_to_bytes(int(res)))
    break
```
</TabItem>
</Tabs>

### SSS???

<Tabs>
<TabItem label="chall.py">
```python
from random import SystemRandom
from Crypto.Util.number import getPrime, isPrime, bytes_to_long

random = SystemRandom()


class Polynomial:
  def __init__(self, p: int, deg: int):
    self.p = p
    self.deg = deg
    self.coeffs = [random.randint(0, p) for _ in range(self.deg + 1)]

  def evaluate(self, x: int) -> int:
    result = 0
    for coeff in reversed(self.coeffs):
      result = (result * x + coeff) % self.p
    return result

  def get_coeffs(self) -> list[int]:
    return self.coeffs

  def set_coeff(self, idx: int, value: int):
    self.coeffs[idx] = value % self.p


def level1():
  p = 2 * getPrime(512)
  f = Polynomial(p, random.randint(8, 16))
  secret = f.get_coeffs()[0]
  print(f"[*] p: {p}")

  x = int(input("gimme your x > "))
  assert 0 < x < p, "ğŸ˜¡No cheating!"

  print(f"[*] share: {f.evaluate(x)}")
  guess = int(input("ğŸ” > "))
  assert guess == secret, "ğŸ˜Try harder~"

  flag = open("flag1.txt", "r").read().strip()
  print("ğŸ¥³ğŸ¥³ğŸ¥³")
  print(f"[+] Here's level1's flag: {flag}")


def level2():
  p = int(input("gimme your p > "))
  assert isPrime(p) and p.bit_length() > 128, "ğŸ˜¡No cheating!"
  f = Polynomial(p, 16)

  for _ in range(10):
    x = int(input("gimme your x > "))
    assert 0 < x < p, "ğŸ˜¡No cheating!"
    print(f"[*] share: {f.evaluate(x)}")

  idx, guess = map(int, input("ğŸ” > ").split(","))
  secret = f.get_coeffs()[idx]
  assert guess == secret, "ğŸ˜Try harder~"

  flag = open("flag2.txt", "r").read().strip()
  print("ğŸ¥³ğŸ¥³ğŸ¥³")
  print(f"[+] Here's level2's flag: {flag}")


def level3():
  p = getPrime(512)
  f = Polynomial(p, 9)
  flag = open("flag3.txt", "r").read().strip()
  assert len(flag) == 44
  secret = bytes_to_long(flag.encode())
  f.set_coeff(0, secret)
  xs = [random.randrange(1, p) for _ in range(10)]
  shares = [f.evaluate(x) for x in xs]
  print(f"[*] p: {p}")
  print(f"[*] xs: {xs}")
  for i, share in enumerate(shares, 1):
    print(hex(share)[:-i] + "?" * i)


def challenge():
  print("ğŸ¥°Welcome to my SSS backroom!")
  while True:
    try:
      choice = int(input("ğŸ“Choose a level to escape > "))
      if choice == 1:
        level1()
      elif choice == 2:
        level2()
      elif choice == 3:
        level3()
      else:
        print("ğŸš«Invalid choice.")
        exit(0)
    except Exception as e:
      print(f"ğŸ˜µError: {e}")


if __name__ == "__main__":
  challenge()
```
</TabItem>
</Tabs>

åŒ…å«3ä¸ªå…³å¡çš„é¢˜ç›®ï¼Œéƒ½æ˜¯ç»™å‡ºå¤šé¡¹å¼çš„æ ¹ç„¶åè¦æ±‚æ¢å¤ä¸€äº›ç³»æ•°ï¼Œç±»ä¼¼Shamir Secret Sharingï¼Œæ‰€ä»¥å«`SSS???`

<Spoiler>å› ä¸ºåˆ†åˆ«çªƒå–è‡ªä¸‰åœºå›½é™…èµ›æ‰€ä»¥ä¸ä¼šè¯¦ç»†è§£é‡Šè§£æ³•ï¼Œè¯·ç›´æ¥å‚è€ƒå„è‡ªçš„åŸé¢˜ã€‚</Spoiler>

- level1æŠ„è‡ª[HKCERT CTF 2023-Solitude, Solitude, Solitude](https://mystiz.hk/posts/2024/2024-01-27-hkcert-ctf-1/#solitude-solitude-solitude)
- level2æŠ„è‡ª[idekCTF 2025-FITM](https://normalsubgroup.cauchy.top/blog/idek2025-writeup/#fang-fa-2)çš„ä¸€éƒ¨åˆ†ï¼Œå¯ä»¥åˆ©ç”¨IDFTæ¢å¤æŒ‡å®šä½ç½®çš„ç³»æ•°ã€‚
- level3æŠ„è‡ª[AlpacaHack round 12-Flag Sharing](https://yu212.hatenablog.com/entry/2025/07/06/180654#Flag-Sharing-6-solves)ï¼Œä¸è¿‡é‚£é¢˜å½“æ—¶æˆ‘æ˜¯ç›´æ¥ç”¨lll_cvpæŒ‰ç…§èŒƒå¾·è’™å¾·è¡Œåˆ—å¼çš„å½¢å¼é€ æ ¼æ‰“CVPè§£çš„ï¼Œæœ‰ç‚¹éé¢„æœŸï¼›è¿™æ¬¡å‡ºé¢˜ä¼˜åŒ–äº†flagçš„å­—ç¬¦åˆ†å¸ƒï¼Œå°å µäº†è¿™ä¸€éé¢„æœŸè§£æ³•ã€‚

å‰ä¸¤é—®åŸºæœ¬ä¸ŠGPT-5èƒ½ä¸€æŠŠæ¢­ï¼Œç¬¬ä¸‰é—®çš„æ ¼ç¡®å®å¡å¾—å¾ˆç´§ï¼ŒæŒ‰@yu212çš„åšæ³•ç”¨æ‹‰æ ¼æœ—æ—¥æ’å€¼çš„å…¬å¼é€ æ ¼è§„çº¦+ä¼˜åŒ–å°±å¥½äº†ã€‚

### Lost Linear Logic

<Tabs>
<TabItem label="chall.py">
```python
from sage.all import random_matrix, vector, GF, ZZ
from Crypto.Util.number import getPrime, bytes_to_long


flag = bytes_to_long(open("flag.txt", "rb").read().strip())
n = 35
m = flag.bit_length()
p = getPrime(256)
F = GF(p)

A = random_matrix(GF(3), m, n).change_ring(F)
A[:, 0] = vector(ZZ, list(map(int, bin(flag)[2:])))
x = random_matrix(F, n, 1)
res = A * x

print(p)
print(list(res.transpose()[0]))
```
</TabItem>
</Tabs>

åŸç‰ˆHSSPï¼Œç›´æ¥æ‰“æ­£äº¤æ ¼å°±è¡Œã€‚

å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬çŸ¥é“$A*x\equiv{0}\pmod{p}$ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬æ‰¾åˆ°$M$æ»¡è¶³$MA\vec{x}=\vec{x}^TA^TM^T\equiv{0}\pmod{p}$ï¼Œé‚£ä¹ˆ$A$å°±åœ¨$M$çš„å·¦æ ¸ç©ºé—´ä¸­ï¼›
è€ŒAçš„å‘é‡åˆéƒ½å¾ˆçŸ­ï¼Œæ‰€ä»¥å¯¹$M$çš„å·¦æ ¸ç©ºé—´ä½œæ ¼è§„çº¦å°±å¯ä»¥æœŸæœ›æ‰¾åˆ°è¿™äº›çŸ­å‘é‡ï¼Œä»è€Œæ¢å¤å‡ºflagã€‚

è€Œåœ¨$\bmod{p}$ä¸‹æ‰¾åˆ°è¿™æ ·çš„$M$çš„æ–¹æ³•ä¹Ÿæ˜¯æ ¼ï¼Œæ„é€ æ–¹æ¡ˆè¯·å‚è€ƒ`solve.py`ã€‚
<Tabs>
<TabItem label="solve.py">
```python
from sage.all import *
from Crypto.Util.number import long_to_bytes
# fmt: off
p = 
res = 
# fmt: on
m = len(res)
n = 35

B = identity_matrix(m).augment(matrix(ZZ, res).transpose()).stack(vector([0] * m + [p]))
ortho = B.LLL()
res = ortho[: m - n, :m]
L = res.transpose().left_kernel_matrix()
print(L.nrows(), L.ncols())
ans = L.LLL()
flag_bits = "".join(str(abs(x)) for x in ans[0])
flag = long_to_bytes(int(flag_bits, 2))
print(flag)
```
</TabItem>
</Tabs>

## Misc
### é“ å†¢éœ™æ£€æµ‹å™¨
<Tabs>
<TabItem label="app.py">
```python
from __future__ import annotations
import os
import secrets
from flask import Flask, request, render_template_string
from werkzeug.utils import secure_filename
from PIL import Image
import torch
import torchvision.transforms as T
from predict import predict_image_with_saved_model

ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg"}
UPLOAD_FOLDER = "./uploads"
FIXED_IMAGE_PATH = "./test_dir/test.png"
FLAG = os.environ.get("FLAG", "H3CTF{test_flag}")
L2_MAX = float("0.5")
MAX_CONTENT_LENGTH = 2 * 1024 * 1024
IMAGENET_MEAN = (0.485, 0.456, 0.406)
IMAGENET_STD = (0.229, 0.224, 0.225)
app = Flask(__name__)
app.config.update(
  UPLOAD_FOLDER=UPLOAD_FOLDER,
  MAX_CONTENT_LENGTH=MAX_CONTENT_LENGTH,
  SECRET_KEY=os.environ.get("SECRET_KEY", secrets.token_hex(16)),
)

os.makedirs(UPLOAD_FOLDER, exist_ok=True)


def allowed_file(filename: str) -> bool:
  return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS


def safe_open_image(path: str) -> Image.Image:
  """Strict image open: verify then reopen in RGB to thwart trivial polyglots."""
  with Image.open(path) as im:
    im.verify()
  im = Image.open(path).convert("RGB")
  return im


def l2_between_images(
  img1: Image.Image, img2: Image.Image, img_size: int = 288
) -> float:
  tfm = T.Compose(
    [
      T.Resize((img_size, img_size)),
      T.ToTensor(),
    ]
  )
  x1 = tfm(img1).view(-1)
  x2 = tfm(img2).view(-1)
  return torch.norm(x1 - x2, p=2).item()


TEMPLATE = """
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Anime Check Â· CTF</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="min-h-screen bg-gray-50 text-gray-800">
    <div class="mx-auto max-w-xl px-4 py-12">
      <div class="text-center mb-8">
        <h1 class="text-3xl font-semibold tracking-tight">Anime Check</h1>
        <p class="text-sm text-gray-500 mt-2">Is this Mizore?</p>
      </div>

      <div class="bg-white rounded-2xl shadow-sm border border-gray-100 p-6">
        <form class="space-y-4" action="/" method="post" enctype="multipart/form-data">
          <div>
            <label for="file" class="block text-sm font-medium text-gray-700">é€‰æ‹©å›¾ç‰‡ï¼ˆ.png /.jpgï¼‰</label>
            <input id="file" name="file" type="file" accept=".png,.jpg,.jpeg,image/png,image/jpeg"
                   class="mt-2 block w-full rounded-xl border border-gray-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white" required />
          </div>
          <button type="submit" class="w-full rounded-xl bg-black text-white py-2.5 text-sm font-medium hover:opacity-90">ä¸Šä¼ é‰´å®š</button>
        </form>
      </div>

      {% if error %}
        <div class="mt-6 rounded-xl bg-red-50 border border-red-200 p-4 text-sm text-red-800">{{ error }}</div>
      {% endif %}

      {% if checked %}
        {% if success %}
          <div class="mt-6 rounded-xl bg-emerald-50 border border-emerald-200 p-4">
            <div class="text-sm text-emerald-800">She is surely NOT Mizore!</div>
            <div class="mt-1 font-mono text-emerald-900 text-base select-all">{{ flag }}</div>
          </div>
        {% else %}
          <div class="mt-6 rounded-xl bg-amber-50 border border-amber-200 p-4 text-sm text-amber-800">
            Not so good...
            <div class="mt-1 font-mono text-emerald-900 text-base select-all">L2 norm = {{ l2 }}</div>
          </div>
        {% endif %}
      {% endif %}

      <footer class="mt-10 text-center text-xs text-gray-400">Â© Kitauji, FIGHT!</footer>
    </div>
  </body>
</html>
"""


@app.route("/", methods=["GET", "POST"])
def index():
  if not os.path.exists(FIXED_IMAGE_PATH):
    return render_template_string(
      TEMPLATE,
      error="æœåŠ¡å™¨é…ç½®é”™è¯¯ï¼šåç«¯å‚è€ƒå›¾ä¸å­˜åœ¨ã€‚",
      checked=False,
    ), 503

  if request.method == "GET":
    return render_template_string(TEMPLATE, checked=False)

  file = request.files.get("file")
  if file is None or file.filename == "":
    return render_template_string(TEMPLATE, error="æœªé€‰æ‹©æ–‡ä»¶ã€‚", checked=False), 400

  if not allowed_file(file.filename):
    return render_template_string(
      TEMPLATE, error="ä»…æ”¯æŒ .png / .jpgã€‚", checked=False
    ), 400

  ext = file.filename.rsplit(".", 1)[1].lower()
  fname = f"{secrets.token_hex(8)}.{ext}"
  save_path = os.path.join(app.config["UPLOAD_FOLDER"], secure_filename(fname))

  try:
    file.save(save_path)
  except Exception:
    return render_template_string(TEMPLATE, error="ä¿å­˜ä¸Šä¼ å¤±è´¥ã€‚", checked=False), 500

  try:
    user_img = safe_open_image(save_path)
  except Exception:
    try:
      os.remove(save_path)
    except Exception:
      pass
    return render_template_string(
      TEMPLATE, error="æ–‡ä»¶ä¸æ˜¯æœ‰æ•ˆå›¾ç‰‡ã€‚", checked=False
    ), 400

  try:
    fixed_img = safe_open_image(FIXED_IMAGE_PATH)
  except Exception:
    try:
      os.remove(save_path)
    except Exception:
      pass
    return render_template_string(
      TEMPLATE, error="æœåŠ¡å™¨å›¾åƒè¯»å–å¤±è´¥ã€‚", checked=False
    ), 503
  try:
    l2 = l2_between_images(user_img, fixed_img, img_size=288)
  except Exception:
    try:
      os.remove(save_path)
    except Exception:
      pass
    return render_template_string(TEMPLATE, error="å›¾åƒå¯¹æ¯”å¤±è´¥ã€‚", checked=False), 500
  try:
    is_target = predict_image_with_saved_model(save_path)[0]
  except Exception:
    is_target = False

  success = ((l2 <= L2_MAX) and (not is_target))
  try:
    os.remove(save_path)
  except Exception:
    pass

  if success:
    return render_template_string(
      TEMPLATE,
      checked=True,
      success=True,
      flag=FLAG,
    )
  else:
    return render_template_string(
      TEMPLATE,
      checked=True,
      success=False,
      l2=f"{l2:.6f}",
    )


if __name__ == "__main__":
  app.run(host="0.0.0.0", port=1337, debug=False)
```
</TabItem>
<TabItem label="predict.py">
```python
def predict_image_with_saved_model(
  img_path: str,
  model_path: str = "./models/anime_classifier_efficientnetv2m_best.pt",
  device: str | None = None,
  threshold: float = 0.5,
):
  import os
  from typing import Dict
  import torch
  import torch.nn as nn
  from PIL import Image
  from torchvision import transforms
  from torchvision.models import efficientnet_v2_m

  assert os.path.exists(model_path), f"ckpt ä¸å­˜åœ¨ï¼š{model_path}"
  raw = torch.load(model_path, map_location="cpu")

  if (
    isinstance(raw, dict)
    and "state_dict" in raw
    and isinstance(raw["state_dict"], dict)
  ):
    state_dict = raw["state_dict"]
    meta_ckpt = raw
  elif isinstance(raw, dict):
    state_dict = raw
    meta_ckpt = {}
  else:
    raise RuntimeError("æ— æ³•è¯†åˆ«çš„ checkpoint æ ¼å¼ã€‚")

  PREFIXES = ("module.", "model.", "_orig_mod.", "_forward_module.")

  def _strip_all_prefixes(k: str):
    changed = True
    while changed:
      changed = False
      for p in PREFIXES:
        if k.startswith(p):
          k = k[len(p) :]
          changed = True
    return k

  state_dict = {_strip_all_prefixes(k): v for k, v in state_dict.items()}
  keys = list(state_dict.keys())
  if "classifier.1.weight" in state_dict:
    fc_w_name = "classifier.1.weight"
  elif "classifier.0.weight" in state_dict:
    fc_w_name = "classifier.0.weight"
  else:
    cand = [k for k in keys if k.endswith(".weight")]
    cand.sort()
    fc_w_name = cand[-1]
  num_classes = state_dict[fc_w_name].shape[0]

  if device is None:
    device = "cuda" if torch.cuda.is_available() else "cpu"
  model = efficientnet_v2_m(weights=None)
  in_features = model.classifier[-1].in_features
  model.classifier[-1] = nn.Linear(in_features, num_classes)

  model.load_state_dict(state_dict, strict=False)

  model.eval().to(device)
  model = model.to(memory_format=torch.channels_last)

  classes = (
    meta_ckpt.get("classes")
    or meta_ckpt.get("meta", {}).get("classes")
    or (
      ["positve", "negative"][:num_classes]
      if num_classes <= 2
      else [f"class_{i}" for i in range(num_classes)]
    )
  )
  pos_name = (
    meta_ckpt.get("positive_class_name")
    or meta_ckpt.get("meta", {}).get("positive_class_name")
    or next((c for c in classes if c.lower() != "negative"), classes[0])
  )
  if pos_name not in classes:
    classes = [pos_name] + [c for c in classes if c != pos_name]

  img_size = int(
    meta_ckpt.get("img_size") or meta_ckpt.get("meta", {}).get("img_size", 288)
  )

  IMAGENET_MEAN = (0.485, 0.456, 0.406)
  IMAGENET_STD = (0.229, 0.224, 0.225)
  eval_tfms = transforms.Compose(
    [
      transforms.Resize((img_size, img_size)),
      transforms.ToTensor(),
      transforms.Normalize(IMAGENET_MEAN, IMAGENET_STD),
    ]
  )

  img = Image.open(img_path).convert("RGB")
  x = eval_tfms(img).unsqueeze(0).to(device, memory_format=torch.channels_last)
  with torch.no_grad(), torch.amp.autocast("cuda", enabled=(device == "cuda")):
    logits = model(x)
    probs = torch.softmax(logits, dim=1)[0].cpu().tolist()

  probs_dict: Dict[str, float] = {
    classes[i]: float(probs[i]) for i in range(len(classes))
  }
  pos_prob = probs_dict[pos_name]

  return bool(pos_prob >= threshold), pos_prob


if __name__ == "__main__":
  res, prob = predict_image_with_saved_model("./test.png")
  print(res, prob)
```
</TabItem>
</Tabs>
![c97b13e365d02959d782346e99ebb85c.png](https://pic.swizzer.cc/2025/10/c97b13e365d02959d782346e99ebb85c.png)

è¿™é¢˜çš„æ€æƒ³æ¥è‡ª[smileyCTF 2025-Project Holoswap](https://blog.swizzer.cc/blog/2025-smileyctf-writeup/#project-holoswap)ï¼Œåœ¨l2 normä¸Šæ‰§è¡ŒPGD Attackã€‚
ä¸ºäº†é¿å…å‡ºç°å»å¹´Lilac 405æ¯é‚£ç§"æ‰‹åŠ¨ä¿®æ”¹å‡ ä¸ªåƒç´ å°±èƒ½é€šè¿‡æ¨¡å‹éªŒè¯"çš„æƒ…å†µï¼Œè¿™æ¬¡åŸºäºEfficientNetV2æ¶æ„è®­ç»ƒäº†ä¸€ä¸ªç¨å¤§ç‚¹çš„æ¨¡å‹(è¿™ä¹Ÿå¯¼è‡´è¿™é¢˜å› ä¸ºå¤ªåƒèµ„æºè€Œæ— æ³•éƒ¨ç½²åˆ°å¹³å°ï¼Œä¸å¾—ä¸åœ¨@Cherrlingå’Œæˆ‘çš„æœºå­ä¸Šå„éƒ¨ç½²äº†ä¸€ä»½ä»¥å‡è½»åç«¯å‹åŠ›)ï¼Œ
å¹¶ä¸”æŠŠl2 normçš„é˜ˆå€¼è°ƒå¾—æ¯”è¾ƒä¸¥æ ¼ã€‚ä¸è¿‡åªè¦è‚¯ç¨å¾®è°ƒè°ƒæ­¥é•¿+å†™ä¸ªæ—©åœç­–ç•¥ï¼Œè¿˜æ˜¯èƒ½æ¯”è¾ƒå®¹æ˜“åœ°æ‰“é€šçš„ã€‚

<Tabs>
<TabItem label="attack.py">
```python
import os
import torch
import torch.nn as nn
import torch.nn.functional as F
from PIL import Image
from torchvision import transforms
from torchvision.transforms import InterpolationMode
from torchvision.models import efficientnet_v2_m
from predict import predict_image_with_saved_model
from tqdm import trange

MODEL_PATH = "../src/models/anime_classifier_efficientnetv2m_best.pt"
FIXED_IMAGE_PATH = "../src/test_dir/test.png"
OUT_PATH = "./adv_submit.png"

IMG_SIZE = 288
IMAGENET_MEAN = (0.485, 0.456, 0.406)
IMAGENET_STD = (0.229, 0.224, 0.225)
EPS_L2 = 0.5
STEPS = 500
STEP_SIZE = 0.0000035
THRESH = 0.5

# è®¾å¤‡
if torch.backends.mps.is_available():
  DEVICE = torch.device("mps")
elif torch.cuda.is_available():
  DEVICE = torch.device("cuda")
else:
  DEVICE = torch.device("cpu")

_server_tfm = transforms.Compose(
  [
    transforms.Resize((IMG_SIZE, IMG_SIZE), interpolation=InterpolationMode.BILINEAR),
    transforms.ToTensor(),
  ]
)


def server_feat_from_pil(pil_img: Image.Image) -> torch.Tensor:
  return _server_tfm(pil_img.convert("RGB")).reshape(-1)


def server_l2_from_tensors(y_pixel_01: torch.Tensor, x0_pil: Image.Image) -> float:
  y_pil = transforms.ToPILImage()(y_pixel_01.clamp(0, 1).detach().cpu())
  fy = server_feat_from_pil(y_pil)
  return torch.norm(fy - server_feat_from_pil(x0_pil), p=2).item()


def load_model_and_meta(model_path: str):
  assert os.path.exists(model_path), f"ckpt ä¸å­˜åœ¨ï¼š{model_path}"
  raw = torch.load(model_path, map_location="cpu")

  if (
    isinstance(raw, dict)
    and "state_dict" in raw
    and isinstance(raw["state_dict"], dict)
  ):
    state_dict = raw["state_dict"]
    meta_ckpt = raw
  elif isinstance(raw, dict):
    state_dict = raw
    meta_ckpt = {}
  else:
    raise RuntimeError("æ— æ³•è¯†åˆ«çš„ checkpoint æ ¼å¼ã€‚")

  PREFIXES = ("module.", "model.", "_orig_mod.", "_forward_module.")

  def strip_prefix(k):
    for p in PREFIXES:
      if k.startswith(p):
        return strip_prefix(k[len(p) :])
    return k

  state_dict = {strip_prefix(k): v for k, v in state_dict.items()}

  keys = list(state_dict.keys())
  if "classifier.1.weight" in state_dict:
    fc_w_name = "classifier.1.weight"
  elif "classifier.0.weight" in state_dict:
    fc_w_name = "classifier.0.weight"
  else:
    cand = [k for k in keys if k.endswith(".weight")]
    cand.sort()
    fc_w_name = cand[-1]
  num_classes = state_dict[fc_w_name].shape[0]

  model = efficientnet_v2_m(weights=None)
  in_features = model.classifier[-1].in_features
  model.classifier[-1] = nn.Linear(in_features, num_classes)
  model.load_state_dict(state_dict, strict=False)
  model.eval().to(DEVICE)

  classes = (
    meta_ckpt.get("classes")
    or meta_ckpt.get("meta", {}).get("classes")
    or (
      ["positve", "negative"][:num_classes]
      if num_classes <= 2
      else [f"class_{i}" for i in range(num_classes)]
    )
  )
  pos_name = (
    meta_ckpt.get("positive_class_name")
    or meta_ckpt.get("meta", {}).get("positive_class_name")
    or next((c for c in classes if c.lower() != "negative"), classes[0])
  )
  if pos_name not in classes:
    classes = [pos_name] + [c for c in classes if c != pos_name]
  pos_idx = classes.index(pos_name)

  return model, pos_idx


def preprocess_tensor_pixel01(x01: torch.Tensor) -> torch.Tensor:
  x = x01.unsqueeze(0)
  x = F.interpolate(
    x,
    size=(IMG_SIZE, IMG_SIZE),
    mode="bilinear",
    align_corners=False,
    antialias=True,
  )
  mean = torch.tensor(IMAGENET_MEAN, device=x.device)[None, :, None, None]
  std = torch.tensor(IMAGENET_STD, device=x.device)[None, :, None, None]
  x = (x - mean) / std
  return x


def main():
  assert os.path.exists(FIXED_IMAGE_PATH), f"åŸå›¾ä¸å­˜åœ¨ï¼š{FIXED_IMAGE_PATH}"
  x0_pil = Image.open(FIXED_IMAGE_PATH).convert("RGB")
  x0_pixel = transforms.ToTensor()(x0_pil)
  y = x0_pixel.to(DEVICE).clone().detach().requires_grad_(True)
  model, pos_idx = load_model_and_meta(MODEL_PATH)

  fx0 = server_feat_from_pil(x0_pil)

  for _ in trange(STEPS):
    logits = model(preprocess_tensor_pixel01(y))
    loss = logits[0, pos_idx]
    g = torch.autograd.grad(loss, y, retain_graph=False, create_graph=False)[0]

    with torch.no_grad():
      g_norm = g.reshape(-1).norm(p=2).clamp(min=1e-12)
      y.add_(-STEP_SIZE * g / g_norm)
      y.clamp_(0.0, 1.0)

      y_pil = transforms.ToPILImage()(y.detach().cpu())
      fy = server_feat_from_pil(y_pil)
      l2_now = torch.norm(fy - fx0, p=2).item()
      if l2_now > EPS_L2:
        alpha = EPS_L2 / l2_now
        y = (x0_pixel.to(DEVICE) + (y - x0_pixel.to(DEVICE)) * alpha).clamp(0, 1)
        y.requires_grad_(True)

  adv_pil = transforms.ToPILImage()(y.clamp(0, 1).detach().cpu())
  adv_pil.save(OUT_PATH, format="PNG")
  adv_disk = Image.open(OUT_PATH).convert("RGB")
  l2_check = torch.norm(server_feat_from_pil(adv_disk) - fx0, p=2).item()

  is_target, pos_prob = predict_image_with_saved_model(
    OUT_PATH, model_path=MODEL_PATH, threshold=THRESH
  )

  print(f"[RESULT] Saved: {OUT_PATH}  (size={adv_disk.size}, orig={x0_pil.size})")
  print(
    f"[CHECK] L2 (server-style) = {l2_check:.6f}  (<= {EPS_L2}? {'YES' if l2_check <= EPS_L2 else 'NO'})"
  )
  print(f"[PRED ] pos_prob = {pos_prob:.6f}  -> is_target = {is_target}  (need False)")


if __name__ == "__main__":
  main()
```
</TabItem>
</Tabs>

### å¿«è¦åæ‰çš„äºŒç»´ç 

<Tabs>
<TabItem label="chall.py">
```python
import numpy as np
from scipy.fftpack import dct
import qrcode
from functools import reduce


def gen_qr(data):
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )
    qr.add_data(data)
    qr.make(fit=True)

    qr_image = qr.make_image(fill='black', back_color='white')
    return np.array(qr_image).astype(float)


def rs(image, size):
    H, W = image.shape
    Ha = H // size * size
    Wa = W // size * size
    print(Ha, Wa)
    return image[:Ha, :Wa]


def bs(image, size):
    return [image[i:i+size, j:j+size].flatten()
            for i in range(0, image.shape[0], size)
            for j in range(0, image.shape[1], size)]


def trans(blocks, size, len):
    mat = np.random.randn(size, len)
    return mat, [mat.dot(dct(block, norm='ortho')) for block in blocks]


def compose(*funcs):
    def compose_two(f, g):
        return lambda x: f(g(x))
    return reduce(compose_two, funcs)


def processor(block_size, rs_size):
    def rsp(img): return rs(img, block_size)
    def bsp(img): return bs(img, block_size)
    def transp(blocks): return trans(blocks, rs_size, block_size**2)

    return compose(transp, bsp, rsp, gen_qr)


flag = open("flag.txt", "r").read().strip()
BS = 8
RS = 20
A, out = processor(BS, RS)(flag)
np.save('A.npy', A)
np.save('output.npy', out)
```
</TabItem>
</Tabs>

è¿™é¢˜è€ƒçš„æ˜¯å‹ç¼©æ„ŸçŸ¥ï¼Œä¹‹å‰å‡ºç»™äº†imaginaryCTF dailyï¼Œè¿™æ¬¡åŸå°ä¸åŠ¨åœ°æ¬äº†è¿‡æ¥ã€‚

å‹ç¼©æ„ŸçŸ¥æ˜¯è¯´è¿™ä¹ˆä¸€ä»¶äº‹ï¼šå¦‚æœä¸€ä¸ªä¿¡å·åœ¨æŸä¸ªå˜æ¢åŸŸï¼ˆæ¯”å¦‚ DCTã€FFTã€å°æ³¢ï¼‰æ˜¯**ç¨€ç–**çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç”¨**è¿œå°‘äºå¥ˆå¥æ–¯ç‰¹é‡‡æ ·å®šç†è¦æ±‚çš„æµ‹é‡æ•°æ¢å¤åŸå§‹ä¿¡å·ã€‚**

é¢˜ç›®çš„æµç¨‹æ˜¯

```txt
flag -> ç”ŸæˆäºŒç»´ç  -> è£å‰ªæˆ8x8å— -> DCTå˜æ¢ -> ä¹˜éšæœºçŸ©é˜µ -> å¾—åˆ°ä½ç»´æŠ•å½±
```

äºŒç»´ç æ˜¯é»‘ç™½ä¸¤è‰²ï¼Œåœ¨ DCT åŸŸä¸‹æ¯”è¾ƒç¨€ç–ï¼Œè€Œè¿™é‡Œçš„ä¹˜éšæœºçŸ©é˜µå¯ä»¥çœ‹ä½œæ˜¯é‡‡æ ·è¿‡ç¨‹ï¼Œæ‰€ä»¥åˆ©ç”¨å‹ç¼©æ„ŸçŸ¥çš„åŸç†å¯ä»¥é€†å‘é‡å»ºåŸå§‹ä¿¡å·ã€‚

å½“ç„¶è¿™é¢˜ä¸­é‡å»ºæ•ˆæœå¹¶ä¸æ˜¯å¾ˆå¥½ï¼Œä¸è¿‡ä¹Ÿè¶³å¤Ÿæ‰«å‡ºflagäº†ã€‚

<Tabs>
<TabItem label="solve.py">
```python
import numpy as np
from scipy.fftpack import idct
from sklearn.linear_model import OrthogonalMatchingPursuit
import matplotlib.pyplot as plt

A = np.load('A.npy')
out = np.load('output.npy')
num_blocks, _ = out.shape
block_size = 8

h_blocks = int(np.sqrt(num_blocks))
w_blocks = h_blocks if h_blocks**2 == num_blocks else num_blocks // h_blocks
Ha, Wa = h_blocks * block_size, w_blocks * block_size
image = np.zeros((Ha, Wa))

for k in range(num_blocks):
    y = out[k]
    omp = OrthogonalMatchingPursuit(n_nonzero_coefs=10)
    omp.fit(A, y)
    x_hat = omp.coef_
    block = idct(x_hat, norm='ortho').reshape((block_size, block_size))
    i, j = divmod(k, w_blocks)
    image[i*block_size:(i+1)*block_size, j*block_size:(j+1)*block_size] = block

plt.imshow(image, cmap='gray')
plt.axis('off')
plt.savefig('recovered_qr.png')
plt.show()
```
</TabItem>
</Tabs>

## Reverse
### ãƒªãƒãƒ¼ã‚¹å•é¡ŒãŒå¤šã™ãã‚‹ï¼

ä¸»è¦è€ƒæ—¶åºä¾§ä¿¡é“çš„ä¸€é¢˜ï¼Œå°±ä¸æ”¾é™„ä»¶/æºç äº†ã€‚level1æ˜¯ç®€å•çš„æµå¯†ç æ€§è´¨ï¼Œlevel2è€ƒå¯Ÿæ—¶åºä¾§ä¿¡é“ã€‚å½“ç„¶gdbä¸‹æ–­ç‚¹æ¯”è¾ƒå†…å­˜ç„¶åé€å­—èŠ‚çˆ†ç ´ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚