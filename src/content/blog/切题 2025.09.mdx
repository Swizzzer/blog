---
title: åˆ‡é¢˜ 2025.09
publishDate: 2025-09-22
description: 'æœˆæ›´è®¡åˆ’(1/1)'
tags: ["CTF", "Crypto", "ç”Ÿæˆå‡½æ•°", "DFS", "PPC", "LCG", "Lattice"]
category: 'Writeups'
draft: false 
lang: ''
---
import { Tabs, TabItem } from 'astro-pure/user';

## crewCTF 2025 - po1337nomial

```python title="server.py"
#!/usr/bin/env python3

from os import getenv
from random import getrandbits, randbytes, randrange, shuffle


FLAG = getenv('FLAG', 'crew{fake_flag}')

a = [getrandbits(32) for _ in range(1337)]
options = {'1': 'Get coefficients', '2': 'Evaluate', '3': 'Unlock flag'}

while options:
    option = input(''.join(f'\n{k}. {v}' for k, v in options.items()) + '\n> ')

    if option not in options:
        break

    options.pop(option)

    if option == '1':
        shuffle(s := a.copy())
        print('s:', s)

    if option == '2':
        x = int(input('x: '))
        a[randrange(0, 1337)] = 1337
        print('y:', sum(a_i * x ** i for i, a_i in enumerate(a)))

    if option == '3':
        if input('k: ') == randbytes(1337).hex():
            print(FLAG)
```

~~ä¸€çœ¼ä¸çœŸï¼Œé‰´å®šä¸ºMT~~

è¦æ‰“MTå°±å¾—æ‹¿åˆ°æœ‰åºçš„è¾“å‡ºï¼Œåªæœ‰ä¹±åºçš„è¾“å‡ºæ˜¯ä¸å¤Ÿçš„ã€‚é€‰é¡¹2å…è®¸æˆ‘ä»¬å¯¹å¤šé¡¹å¼æ±‚å€¼ï¼Œæ‰€ä»¥Swizzerçš„ç¬¬ä¸€ååº”æ˜¯ä¼ å…¥ä¸€ä¸ªå¾ˆå¤§çš„xï¼Œæ‹¿åˆ°å€¼åæŒ‰xè¿›åˆ¶å±•å¼€å°±èƒ½æ‹¿åˆ°æ‰€æœ‰ç³»æ•°ï¼Œæ¥ç€å°±èƒ½æ„‰å¿«åœ°æ‰“MTäº†ã€‚ç„¶è€Œç°å®å¹¶æ²¡æœ‰è¿™ä¹ˆç¾å¥½(è¿œç¨‹ç¯å¢ƒğŸˆšï¸äº†ï¼Œæˆªå›¾æ˜¯æœ¬åœ°æµ‹è¯•ã€‚è¿œç¨‹ä¹Ÿæ˜¯åŒæ ·çš„æŠ¥é”™)ï¼š

![alt text](assets/image-62.png)

Pythoné»˜è®¤çš„4300digitsé™åˆ¶ç›´æ¥å µæ­»äº†è¿™æ¡è·¯ã€‚

> ä¸è¿‡ä¹Ÿæ˜¯ï¼Œè¦æ˜¯è¿™æ¡è·¯èƒ½èµ°é€šé‚£é€‰é¡¹1å°±å®Œå…¨æ²¡ç”¨äº†xD

ä¸è¿‡æ²¡å…³ç³»ï¼ŒSwizzerè¿˜å¯ä»¥äºŒæ¬¡å¯åŠ¨ï¼è„‘æµ‹äº†ä¸€ä¸‹ï¼Œè¿™é¢˜èƒ½ä¼ å…¥çš„xæœ€å¤§ä¹Ÿå°±æ˜¯1600å·¦å³ï¼Œè‡³å°‘æ˜¯æ¯”1337å¤§çš„ã€‚æœ‰æ²¡æœ‰å¯èƒ½æˆ‘ä»¬ä¼ å…¥ä¸€ä¸ªæ•°pï¼Œèƒ½ä½¿å¾—1337ä¸ªç³»æ•°åœ¨æ¨¡pä¸‹åˆšå¥½åˆ’åˆ†åˆ°ä¸åŒçš„å‰©ä½™ç±»å‘¢ï¼Ÿè¿™æ ·ç»“åˆé€‰é¡¹1å°±èƒ½é ä½™æ•°å¯¹åº”æ¢å¤ç³»æ•°äº†â€”â€”**å¯æƒœï¼Œæµ‹è¯•åå‘ç°ä¾ç„¶ä¸è¡Œ**ã€‚

è¿™ä¸€æ­¥æµ‹ä¸‹æ¥å‘ç°éšä¾¿å–ä¸€ä¸ª1000~1500ä¹‹é—´çš„xï¼Œæ‰€æœ‰ç³»æ•°æ¨¡xä¸€å…±å¤§æ¦‚800å¤šç§å–å€¼ã€‚è¿™å°±è¯´æ˜è¿™äº›æ¨¡xå‰©ä½™ç±»ä¸­æ€»æœ‰ä¸€äº›æ˜¯å¯¹åº”å”¯ä¸€ä¸€ä¸ªç³»æ•°çš„ï¼Œè¿™è¶³ä»¥è®©æˆ‘ä»¬æ¢å¤å‡ºéƒ¨åˆ†ç³»æ•°ã€‚åŒæ—¶è¿™ä¹Ÿç»™å‡ºäº†DFSçš„å¯èƒ½â€”â€”æ¯é¡¹ç³»æ•°éƒ½è½åœ¨ä¸€ä¸ªå‰©ä½™ç±»é‡Œï¼Œ800å¤šç§å‰©ä½™ç±»ï¼Œå¯ä»¥æƒ³è§æ¯ç§å‰©ä½™ç±»é‡Œçš„å€™é€‰ç³»æ•°ä¹Ÿä¸ä¼šå¾ˆå¤šï¼Œæ¯æœä¸€å±‚åªè¦å»å¯¹åº”çš„å‰©ä½™ç±»é‡Œæœé‚£å‡ ç§å¯èƒ½å°±è¡Œã€‚

```python title="solve.py" collapse={12-91}
from pwn import *
from tqdm import trange
from gf2bv import LinearSystem
from gf2bv.crypto.mt import MT19937
from collections import Counter, defaultdict
from ast import literal_eval
import sys

sys.setrecursionlimit(10**6)


def mt19937(bs, out):
  lin = LinearSystem([32] * 624)
  mt = lin.gens()
  rng = MT19937(mt)
  zeros = []
  for o in out:
    zeros.append(rng.getrandbits(bs) ^ int(o))
  zeros.append(mt[0] ^ int(0x80000000))
  sol = lin.solve_one(zeros)
  rng = MT19937(sol)
  pyrand = rng.to_python_random()
  return pyrand


def dfs(s, x, y):
  n = len(s)
  marker = 1337

  ori_s = list(s)

  for r in trange(n):
    si = s[r]
    s[r] = marker
    residues = defaultdict(Counter)
    for val in s:
      residues[val % x][val] += 1
    a = [None] * n

    def helper(i, v):
      if i == n:
        return v == 0
      rmod = v % x
      bucket = residues.get(rmod)
      if not bucket:
        return False
      cands = sorted(bucket.items(), key=lambda kv: (kv[1], kv[0]))
      for val, cnt in cands:
        if bucket[val] == 0:
          continue
        bucket[val] -= 1
        a[i] = val
        nv = v - val
        if nv % x == 0:
          if helper(i + 1, nv // x):
            return True

        bucket[val] += 1
        a[i] = None

      return False

    ok = helper(0, y)
    if ok:
      if any(v is None for v in a):
        s[r] = si
        continue
      if Counter(a) == Counter(s):
        s[r] = si
        try:
          idx = a.index(marker)
        except ValueError:
          return a
        ori_cnt = Counter(ori_s)
        a_cnt = Counter(a)
        a_cnt[marker] -= 1
        if a_cnt[marker] <= 0:
          del a_cnt[marker]

        missed = ori_cnt - a_cnt
        if not missed:
          return None
        missed_val = next(iter(missed.elements()))
        a[idx] = missed_val
        if Counter(a) == Counter(ori_s):
          return a
        else:
          s[r] = si
          continue
    s[r] = si
  return None


def solve(io):
  x = 1500
  io.sendlineafter(b"> ", b"1")
  io.recvuntil(b"s: ")
  s = literal_eval(io.recvline().decode())
  io.sendlineafter(b"> ", b"2")
  io.sendlineafter(b"x: ", str(x).encode())
  io.recvuntil(b"y: ")
  y = literal_eval(io.recvline().decode())
  a = dfs(s, x, y)
  assert a
  RNG = mt19937(32, a)
  assert all(aa == RNG.getrandbits(32) for aa in a)
  shuffled = a.copy()
  RNG.shuffle(shuffled)
  assert shuffled == s
  RNG.randrange(0, 1337)
  io.sendlineafter(b"> ", b"3")
  io.sendlineafter(b"k: ", RNG.randbytes(1337).hex().encode())
  io.success(io.recvline().decode())


if __name__ == "__main__":
  context.log_level = "info"
  io = process(["python", "server.py"])
  solve(io)
```

## crewCTF 2025 - IOIOIOI

### TL; DR
é¢˜ç›®è¦æ±‚ç»Ÿè®¡é•¿åº¦ä¸º $N$ï¼Œåˆ†æ•°ä¸º $K$ çš„å­—ç¬¦ä¸²ï¼ˆå­—æ¯é›†åˆ $\{I,O\}$ï¼‰åœ¨æ¨¡998244353æ„ä¹‰ä¸‹çš„ä¸ªæ•°ã€‚åˆ†æ•°å®šä¹‰ä¸ºå­—ç¬¦ä¸²ä¸­æ‰€æœ‰å½¢å¦‚ $I(OI)^t$ï¼ˆé•¿åº¦ $2t+1$ï¼Œä¾‹å¦‚ `IOI`, `IOIOI`, ...ï¼‰çš„è¿ç»­å­ä¸²çš„ä¸ªæ•°ã€‚æ—¶é—´é™åˆ¶5minï¼Œ$1 â‰¦ N â‰¦ 10^{18}ï¼Œ0 â‰¦ K â‰¦ 1000$

> ex. score("IOIOIO") = 2 ("IOI") + 1 ("IOIOI") = 3

å°†æ‰€æœ‰å­—ç¬¦ä¸²ç¼–ç ä¸ºäºŒå…ƒç”Ÿæˆå‡½æ•°ï¼š

$$
G(x, y) = \sum_{m \geq 1} x^{2m - 1} y^{\binom{m}{2}}, 
$$

$$
F(x, y) = \frac{x + (1+x^2)G}{1 - x - (1+x+x^2)G},
$$

é¢˜ç›®è¦æ±‚çš„å°±æ˜¯ç³»æ•°

$$
[x^N y^K] F(x, y)
$$


### è§‚å¯Ÿ
é¦–å…ˆè¿™ä¸ªæ¨¡æ•°ä¸€çœ¼NTTï¼Œé‚£ä¹ˆå°±å¾—æƒ³åŠæ³•å¾€å¤šé¡¹å¼ä¸Šé æ‹¢ã€‚ä¸€ä¸ªå…³é”®è§‚å¯Ÿæ˜¯ï¼ŒæŠŠå­—ç¬¦ä¸²æŒ‰æœ€é•¿äº¤æ›¿å­æ®µåˆ‡å¼€ï¼ˆæŠŠè¿ç»­äº¤æ›¿çš„æ®µåˆ†å‡ºæ¥ï¼Œæ¯”å¦‚ `IOIOI`ã€`OIO`ã€`I`ï¼Œ...ï¼‰åï¼Œä»»ä¸€ `I(OI)^t` ç±»å‹çš„å­ä¸²å¿…é¡»å®Œå…¨è½åœ¨æŸä¸ªäº¤æ›¿æ®µå†…ï¼Œå› æ­¤æ•´ä½“ score ç­‰äºå¯¹æ¯ä¸ªä»¥ `I` å¼€å¤´çš„äº¤æ›¿æ®µå†…éƒ¨è´¡çŒ®çš„ä¸‰è§’å½¢æ•°çš„å’Œã€‚

- å¯¹ä»¥ `I` å¼€å¤´ï¼Œä¸”é•¿åº¦ä¸º $2q+1$ çš„äº¤æ›¿æ®µï¼ˆå¥‡é•¿å¹¶é¦–å°¾ç›¸åŒï¼‰ï¼Œå®ƒå†…éƒ¨åŒ…å«çš„æ‰€æœ‰è¿™äº›æ¨¡å¼çš„æ€»æ•°æ°å¥½æ˜¯ä¸‰è§’æ•°

  $$
  T(q)=1+2+\dots+q=\frac{q(q+1)}{2}.
  $$

  ä¾‹å¦‚ `IOIOI`ï¼ˆé•¿åº¦5ï¼Œå¯¹åº” $q=2$ï¼‰å†…éƒ¨å‡ºç°æ•°ä¸º $T(2)=3$ï¼Œåˆ†åˆ«æ˜¯ä¸¤ä¸ª `IOI` å’Œä¸€ä¸ª `IOIOI`ã€‚

- å¯¹ä»¥ `O` å¼€å¤´çš„äº¤æ›¿æ®µï¼Œè‹¥é•¿åº¦ä¸º $2q+1$ï¼ˆå¥‡é•¿ï¼‰ï¼Œå®ƒå†…éƒ¨ä»¥ `I` å¼€å¤´çš„æ¨¡å¼æ•°é‡ä¸º $T(q-1)$ï¼ˆå› ä¸ºç¬¬ä¸€ä¸ªä½ç½®ä¸æ˜¯ `I`ï¼Œä»¥ `I` å¼€å¤´çš„æ¨¡å¼è¦ä»ç¬¬äºŒä¸ªå­—ç¬¦å¼€å§‹è®¡æ•°ï¼‰ã€‚å¯¹å¶åœ°ï¼Œä»¥ `I` å¼€å¤´çš„å¶é•¿äº¤æ›¿æ®µä¹Ÿä¼šæœ‰ç‰¹å®šçš„è´¡çŒ®ã€‚

è‡³æ­¤ï¼Œæˆ‘ä»¬æŠŠè®¡æ•°é—®é¢˜è½¬åŒ–ä¸ºæŒ‰äº¤æ›¿æ®µæ‹¼æ¥çš„ç»„åˆè®¡æ•°é—®é¢˜ï¼šæŠŠé•¿åº¦ $N$ çš„å­—ç¬¦ä¸²çœ‹ä½œè‹¥å¹²äº¤æ›¿æ®µï¼ˆæ¯æ®µçš„é•¿åº¦ã€é¦–å­—æ¯ã€ä»¥åŠè¯¥æ®µå†…éƒ¨å¯¹ `score` çš„è´¡çŒ®ï¼‰ï¼ŒæŠŠè¿™äº›æ®µæŒ‰èƒ½å¦é¦–å°¾æ‹¼æ¥çš„è§„åˆ™æ‹¼èµ·æ¥ï¼Œç»Ÿè®¡æ€» `score=K` çš„æ–¹æ¡ˆæ•°ã€‚


### å¼•å…¥ç”Ÿæˆå‡½æ•°

å®šä¹‰ç”Ÿæˆå‡½æ•°

$$
G(x,u)=\sum_{n\ge0}\sum_{k\ge0} a_{n,k}\,x^n u^k,
$$

å…¶ä¸­ $a_{n,k}$ ä¸ºé•¿åº¦ä¸º $n$ã€score ä¸º $k$ çš„å­—ç¬¦ä¸²æ•°é‡ã€‚æˆ‘ä»¬è¦çš„å³æ˜¯ç³»æ•° $[x^N u^K]\,G(x,u)$ã€‚

åˆ©ç”¨ä¸Šé¢çš„äº¤æ›¿æ‹¼æ¥æ€æƒ³ï¼Œå¯ä»¥æŠŠæ¯ç§ç±»å‹çš„äº¤æ›¿æ®µçœ‹ä½œä¸€ä¸ªâ€œå¸¦æƒçš„å­—â€ï¼ˆæƒä¸º $x^{\text{æ®µé•¿}} u^{\text{æ®µå†…è´¡çŒ®}}$ï¼‰ã€‚è€ƒè™‘çŠ¶æ€ä¸ºâ€œå½“å‰æœ«å°¾å­—æ¯æ˜¯ I / Oâ€ä¸¤ç§æƒ…å†µï¼Œæ®µçš„æ‹¼æ¥å˜ä¸ºçŠ¶æ€ä¹‹é—´çš„è½¬æ¢ã€‚äºæ˜¯å¯ä»¥æ„é€ ä¸€ä¸ª $2\times2$ çš„çŸ©é˜µç”Ÿæˆå‡½æ•° $M(x,u)$ï¼Œå…¶å„é¡¹æ˜¯ä»æŸä¸€æœ«å°¾å­—æ¯åˆ°ä¸‹ä¸€æœ«å°¾å­—æ¯æ‰€èƒ½è¿½åŠ çš„æ®µçš„ç”Ÿæˆå‡½æ•°ï¼š

* $A(x,u)$ â€”â€” ä» `I` è¿½åŠ ä¸€ä¸ªæ®µï¼Œä½¿å¾—æ®µ**å¼€å§‹ä¸”ç»“æŸéƒ½æ˜¯ I**ï¼ˆå³æ®µé•¿åº¦ä¸ºå¥‡æ•° $2q+1$ï¼‰ï¼Œå¯¹åº”çš„æƒæ˜¯ $x^{2q+1} u^{T(q)}$ã€‚å› æ­¤åœ¨ä»£ç é‡Œ `A` åœ¨æŒ‡æ•° $2q+1$ å¤„æ”¾å…¥ $u^{T(q)}$ã€‚
* $B(x,u)$ â€”â€” ä» `O` è¿½åŠ ä¸€ä¸ªæ®µï¼Œä½¿å¾—æ®µ**å¼€å§‹ä¸”ç»“æŸéƒ½æ˜¯ O**ï¼ˆå¥‡é•¿ï¼‰ï¼Œæ®µå†…ä»¥ `I` å¼€å¤´çš„æ¨¡å¼è´¡çŒ®æ˜¯ $T(q-1)$ï¼ˆå¯¹ $q\ge1$ï¼‰ï¼Œæ‰€ä»¥ `B` åœ¨æŒ‡æ•° $2q+1$ å¤„æ”¾å…¥ $u^{T(q-1)}$ï¼ˆå½“ $q=0$ æ—¶è§†ä¸º 0ï¼‰ã€‚
* $E(x,u)$ â€”â€” é•¿åº¦ä¸ºå¶æ•° $2q+2$ çš„äº¤æ›¿æ®µï¼ˆä¼šæŠŠ Iâ†’O æˆ– Oâ†’Iï¼‰ï¼Œå…¶å†…éƒ¨å¯¹ score çš„è´¡çŒ®æ˜¯ $T(q)$ï¼Œå› æ­¤ `E` åœ¨æŒ‡æ•° $2q+2$ å¤„æ”¾å…¥ $u^{T(q)}$ã€‚

å› æ­¤æœ‰

$$
M(x,u)=\begin{pmatrix} A & E \\ E & B \end{pmatrix},
$$

åœ¨è¿™ç§çŠ¶æ€æœºä¸‹ï¼Œä»â€œç©ºâ€çš„åˆå§‹ï¼ˆä¸è€ƒè™‘é¦–å­—æ¯ï¼‰å‡ºå‘ï¼Œæ‰€æœ‰å­—ç¬¦ä¸²å¯¹åº”äºå¯¹ $M$ çš„ä»»æ„æ¬¡æ•°çš„ä¸²è”ï¼ˆåŒ…æ‹¬ 0 æ¬¡ï¼‰ï¼Œå› æ­¤æ€»ä½“ç”Ÿæˆå‡½æ•°æ˜¯

$$
G(x,u)=(1,1)\cdot (I-M(x,u))^{-1} \cdot (1,1)^{T}.
$$

æŠŠçŸ©é˜µé€†å†™æˆä¼´éšçŸ©é˜µ / è¡Œåˆ—å¼çš„å½¢å¼å¯ä»¥åŒ–ç®€ä¸ºä¸€ä¸ªæœ‰ç†å‡½æ•°ï¼Œåˆ†æ¯æ˜¯ $Q(x,u)=\det(I-M)= (1-A)(1-B)-E^2$ï¼Œåˆ†å­æ˜¯ $P(x,u)=2-(A+B)+2E$

äºæ˜¯

$$
G(x,u)=\frac{P(x,u)}{Q(x,u)}.
$$

å–

```cpp
ONEminusA = 1 - A;
ONEminusB = 1 - B;
D1 = (1-A)*(1-B);
E2 = E*E;
D = D1 - E2;      // = Q(x,u)
P = 2 - (A+B) + 2E; // = P(x,u)
Q = D;
```

å› æ­¤é—®é¢˜å°±å˜ä¸ºè®¡ç®—æœ‰ç†å‡½æ•° $\dfrac{P(x,u)}{Q(x,u)}$ åœ¨ $x^N$ é¡¹çš„ç³»æ•°å¤šé¡¹å¼ï¼Œå†å–è¯¥å¤šé¡¹å¼çš„ $u^K$ ç³»æ•°ã€‚åç»­çš„å¤šé¡¹å¼ç›¸å…³æ“ä½œæ‰¾æ¿å­åŠ é€Ÿå³å¯ï¼Œæˆ‘çš„ä»£ç é‡Œæœ€ç»ˆç”¨äº†Bostan-Moriã€NTTå’Œå¥‡å¶åˆ†è§£è¿™å‡ å¤§å—çš„ä¼˜åŒ–ã€‚

### solve
<Tabs>
<TabItem label="solver.cpp">
```cpp title="solver.cpp" collapse={2-337}
// g++ -O3 -march=native -std=c++17 -pipe solver.cpp -o solver
#include <bits/stdc++.h>
using namespace std;

static const uint32_t MOD = 998244353;
static const uint32_t G = 3;

static inline uint32_t addm(uint32_t a, uint32_t b) {
  uint32_t c = a + b;
  return c >= MOD ? c - MOD : c;
}
static inline uint32_t subm(uint32_t a, uint32_t b) {
  return a >= b ? a - b : a + MOD - b;
}
static inline uint32_t mulm(uint64_t a, uint64_t b) {
  return (uint32_t)((a * b) % MOD);
}
static inline uint32_t powm(uint32_t a, uint64_t e) {
  uint64_t r = 1, x = a;
  while (e) {
    if (e & 1)
      r = (r * x) % MOD;
    x = (x * x) % MOD;
    e >>= 1;
  }
  return (uint32_t)r;
}

struct NTTScalar {
  int n;
  vector<uint32_t> w, iw;
  vector<int> rev;
  void init(int N) {
    n = N;
    w.resize(n);
    iw.resize(n);
    rev.resize(n);
    for (int i = 1; i < n; i++)
      rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (n >> 1) : 0);
    uint32_t root = powm(G, (MOD - 1) / n), iroot = powm(root, MOD - 2);
    w[0] = 1;
    iw[0] = 1;
    for (int i = 1; i < n; i++) {
      w[i] = mulm(w[i - 1], root);
      iw[i] = mulm(iw[i - 1], iroot);
    }
  }
  void dft(uint32_t *a, bool inv) {
    for (int i = 1; i < n; i++) {
      int j = rev[i];
      if (i < j)
        swap(a[i], a[j]);
    }
    for (int len = 2; len <= n; len <<= 1) {
      int step = n / len;
      for (int i = 0; i < n; i += len) {
        for (int j = 0; j < (len >> 1); j++) {
          uint32_t u = a[i + j];
          uint32_t v = mulm(a[i + j + (len >> 1)], (inv ? iw : w)[step * j]);
          a[i + j] = addm(u, v);
          a[i + j + (len >> 1)] = subm(u, v);
        }
      }
    }
    if (inv) {
      uint32_t invn = powm(n, MOD - 2);
      for (int i = 0; i < n; i++)
        a[i] = mulm(a[i], invn);
    }
  }
};

static inline int ceil_pow2(int x) {
  int n = 1;
  while (n < x)
    n <<= 1;
  return n;
}
static inline int calc_M(int K) {
  int lo = 0, hi = K + 2;
  while (lo + 1 < hi) {
    int mid = (lo + hi) >> 1;
    if (1LL * mid * (mid - 1) / 2 <= K)
      lo = mid;
    else
      hi = mid;
  }
  return lo;
}

struct RingContext {
  int K, Lu;
  NTTScalar ntt_u;
  vector<uint32_t> mon1, mono_table;
  void init(int K_) {
    K = K_;
    Lu = ceil_pow2(2 * K + 1);
    ntt_u.init(Lu);
    mon1.resize(Lu);
    for (int j = 0; j < Lu; j++)
      mon1[j] = ntt_u.w[j];
    mono_table.assign((K + 1) * Lu, 0);
    for (int j = 0; j < Lu; j++)
      mono_table[j] = 1;
    for (int t = 1; t <= K; t++) {
      uint32_t *prev = &mono_table[(t - 1) * Lu];
      uint32_t *curr = &mono_table[t * Lu];
      for (int j = 0; j < Lu; j++)
        curr[j] = mulm(prev[j], mon1[j]);
    }
  }
  inline const uint32_t *mono(int t) const { return &mono_table[t * Lu]; }
  void truncate_block(uint32_t *blk) {
    ntt_u.dft(blk, true);
    memset(blk + (K + 1), 0, sizeof(uint32_t) * (Lu - (K + 1)));
    ntt_u.dft(blk, false);
  }
};

struct XNTT {
  unordered_map<int, NTTScalar> cache;
  NTTScalar &get(int Lx) {
    auto it = cache.find(Lx);
    if (it != cache.end())
      return it->second;
    NTTScalar c;
    c.init(Lx);
    return cache.emplace(Lx, std::move(c)).first->second;
  }
  void dft_blocks(vector<uint32_t> &a, int Lx, int Lu, bool inv) {
    NTTScalar &ctx = get(Lx);
    for (int i = 1; i < Lx; i++) {
      int j = ctx.rev[i];
      if (i < j) {
        uint32_t *p = &a[i * Lu];
        uint32_t *q = &a[j * Lu];
        for (int t = 0; t < Lu; t++)
          swap(p[t], q[t]);
      }
    }
    for (int len = 2; len <= Lx; len <<= 1) {
      int step = Lx / len;
      for (int i = 0; i < Lx; i += len) {
        for (int j = 0; j < (len >> 1); j++) {
          uint32_t w = (inv ? ctx.iw[step * j] : ctx.w[step * j]);
          uint32_t *u = &a[(i + j) * Lu];
          uint32_t *v = &a[(i + j + (len >> 1)) * Lu];
          for (int t = 0; t < Lu; t++) {
            uint32_t vv = mulm(v[t], w), uu = u[t];
            u[t] = addm(uu, vv);
            v[t] = subm(uu, vv);
          }
        }
      }
    }
    if (inv) {
      uint32_t invn = powm(Lx, MOD - 2);
      for (uint32_t &x : a)
        x = mulm(x, invn);
    }
  }
};

static vector<uint32_t> multiply_x_blocks(const vector<uint32_t> &A,
                                          const vector<uint32_t> &B, int Lu,
                                          XNTT &xntt) {
  int nA = (int)A.size() / Lu, nB = (int)B.size() / Lu;
  int need = nA + nB - 1, Lx = ceil_pow2(need);
  vector<uint32_t> FA(Lx * Lu), FB(Lx * Lu);
  memcpy(FA.data(), A.data(), sizeof(uint32_t) * nA * Lu);
  memcpy(FB.data(), B.data(), sizeof(uint32_t) * nB * Lu);
  xntt.dft_blocks(FA, Lx, Lu, false);
  xntt.dft_blocks(FB, Lx, Lu, false);
  for (int i = 0; i < Lx; i++) {
    uint32_t *pa = &FA[i * Lu];
    uint32_t *pb = &FB[i * Lu];
    for (int j = 0; j < Lu; j++)
      pa[j] = mulm(pa[j], pb[j]);
  }
  xntt.dft_blocks(FA, Lx, Lu, true);
  FA.resize(need * Lu);
  return FA;
}
static vector<uint32_t> take_even(const vector<uint32_t> &A, int Lu) {
  int n = (int)A.size() / Lu, m = (n + 1) / 2;
  vector<uint32_t> R(m * Lu);
  for (int i = 0; i < m; i++)
    memcpy(&R[i * Lu], &A[(2 * i) * Lu], sizeof(uint32_t) * Lu);
  return R;
}
static vector<uint32_t> take_odd(const vector<uint32_t> &A, int Lu) {
  int n = (int)A.size() / Lu, m = n / 2;
  vector<uint32_t> R(m * Lu);
  for (int i = 0; i < m; i++)
    memcpy(&R[i * Lu], &A[(2 * i + 1) * Lu], sizeof(uint32_t) * Lu);
  return R;
}
static void truncate_poly_blocks(vector<uint32_t> &P, RingContext &rc) {
  int n = (int)P.size() / rc.Lu;
  for (int i = 0; i < n; i++)
    rc.truncate_block(&P[i * rc.Lu]);
}

static vector<uint32_t> poly_add(const vector<uint32_t> &A,
                                 const vector<uint32_t> &B, int Lu) {
  int nA = (int)A.size() / Lu, nB = (int)B.size() / Lu, n = max(nA, nB);
  vector<uint32_t> R(n * Lu, 0);
  for (int i = 0; i < n; i++) {
    uint32_t *pr = &R[i * Lu];
    if (i < nA)
      memcpy(pr, &A[i * Lu], sizeof(uint32_t) * Lu);
    if (i < nB) {
      const uint32_t *pb = &B[i * Lu];
      for (int j = 0; j < Lu; j++)
        pr[j] = addm(pr[j], pb[j]);
    }
  }
  return R;
}
static vector<uint32_t> poly_sub(const vector<uint32_t> &A,
                                 const vector<uint32_t> &B, int Lu) {
  int nA = (int)A.size() / Lu, nB = (int)B.size() / Lu, n = max(nA, nB);
  vector<uint32_t> R(n * Lu, 0);
  for (int i = 0; i < n; i++) {
    if (i < nA)
      memcpy(&R[i * Lu], &A[i * Lu], sizeof(uint32_t) * Lu);
    if (i < nB) {
      const uint32_t *pb = &B[i * Lu];
      uint32_t *pr = &R[i * Lu];
      for (int j = 0; j < Lu; j++)
        pr[j] = subm(pr[j], pb[j]);
    }
  }
  return R;
}
static void poly_scale_inplace(vector<uint32_t> &A, int /*Lu*/, uint32_t c) {
  if (c == 1)
    return;
  for (uint32_t &x : A)
    x = mulm(x, c);
}

static void build_ABE(int K, RingContext &rc, vector<uint32_t> &A,
                      vector<uint32_t> &B, vector<uint32_t> &E) {
  int M = calc_M(K);
  int degA = 2 * M + 1, degE = 2 * M;
  A.assign((degA + 1) * rc.Lu, 0);
  B.assign((degA + 1) * rc.Lu, 0);
  E.assign((degE + 1) * rc.Lu, 0);
  vector<int> T(M + 1);
  for (int q = 0; q <= M; q++)
    T[q] = q * (q + 1) / 2;

  for (int q = 0; q <= M; q++) {
    int d = 2 * q + 1, t = T[q];
    if (t <= K) {
      memcpy(&A[d * rc.Lu], rc.mono(t), sizeof(uint32_t) * rc.Lu);
    }
  }
  for (int q = 0; q <= M; q++) {
    int d = 2 * q + 1, tm1 = (q >= 1 ? T[q - 1] : 0);
    if (tm1 <= K) {
      memcpy(&B[d * rc.Lu], rc.mono(tm1), sizeof(uint32_t) * rc.Lu);
    }
  }
  for (int q = 0; q <= M - 1; q++) {
    int d = 2 * q + 2, t = T[q];
    memcpy(&E[d * rc.Lu], rc.mono(t), sizeof(uint32_t) * rc.Lu);
  }
}

static uint32_t solve_one(uint64_t N, int K) {
  RingContext rc;
  rc.init(K);
  XNTT xntt;

  vector<uint32_t> A, B, E;
  build_ABE(K, rc, A, B, E);

  vector<uint32_t> ONE(rc.Lu, 0);
  for (int j = 0; j < rc.Lu; j++)
    ONE[j] = 1;
  auto ONEminusA = poly_sub(ONE, A, rc.Lu);
  auto ONEminusB = poly_sub(ONE, B, rc.Lu);

  auto D1 = multiply_x_blocks(ONEminusA, ONEminusB, rc.Lu, xntt);
  auto E2 = multiply_x_blocks(E, E, rc.Lu, xntt);
  auto D = poly_sub(D1, E2, rc.Lu);

  auto ApB = poly_add(A, B, rc.Lu);
  auto two = ONE;
  poly_scale_inplace(two, rc.Lu, 2);
  auto twoE = E;
  poly_scale_inplace(twoE, rc.Lu, 2);
  auto tmp = poly_sub(two, ApB, rc.Lu);
  auto P = poly_add(tmp, twoE, rc.Lu);
  auto Q = std::move(D);

  truncate_poly_blocks(P, rc);
  truncate_poly_blocks(Q, rc);

  while (N > 0) {
    vector<uint32_t> Qhat = Q;
    int qn = (int)Q.size() / rc.Lu;
    for (int i = 1; i < qn; i += 2) {
      uint32_t *blk = &Qhat[i * rc.Lu];
      for (int j = 0; j < rc.Lu; j++)
        blk[j] = (blk[j] == 0 ? 0u : MOD - blk[j]);
    }
    auto R = multiply_x_blocks(P, Qhat, rc.Lu, xntt);
    auto S = multiply_x_blocks(Q, Qhat, rc.Lu, xntt);

    vector<uint32_t> Pn = (N & 1) ? take_odd(R, rc.Lu) : take_even(R, rc.Lu);
    vector<uint32_t> Qn = take_even(S, rc.Lu);

    truncate_poly_blocks(Pn, rc);
    truncate_poly_blocks(Qn, rc);

    P.swap(Pn);
    Q.swap(Qn);
    N >>= 1;
  }

  rc.ntt_u.dft(&P[0], true);
  return (K < rc.Lu ? P[K] % MOD : 0u);
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  uint64_t N;
  int K;
  while ((cin >> N >> K)) {
    cout << solve_one(N, K) << '\n' << flush;
  }
  return 0;
}
```
</TabItem>
<TabItem label="solve.py">
```python title="solve.py"
from pwn import *
from tqdm import trange

import os, subprocess, threading, atexit

MOD = 998244353
_proc = None
_proc_lock = threading.Lock()


def _ensure_proc():
  global _proc
  with _proc_lock:
    if _proc is not None:
      return True
    exe = os.path.join(os.path.dirname(__file__), "solver")
    if not os.path.exists(exe):
      return False
    _proc = subprocess.Popen(
      [exe],
      stdin=subprocess.PIPE,
      stdout=subprocess.PIPE,
      bufsize=1,
      text=True,
    )

    def _cleanup():
      try:
        if _proc:
          _proc.stdin.close()
          _proc.terminate()
      except Exception:
        pass

    atexit.register(_cleanup)
    return True


def _call_native(N, K):
  if not _ensure_proc():
    return None
  try:
    _proc.stdin.write(f"{N} {K}\n")
    _proc.stdin.flush()
    line = _proc.stdout.readline()
    if not line:
      return None
    return int(line.strip())
  except Exception:
    return None


def Solve(N, K):
  ans = _call_native(N, K)
  return ans


def processing(io):
  for _ in trange(300):
    io.recvuntil(b"Test ")
    io.recvline()
    N = int(io.recvlineS().split("=")[1].strip())
    K = int(io.recvlineS().split("=")[1].strip())
    ans = Solve(N, K)
    io.sendlineafter(b"Your answer: ", str(ans))
  io.interactive()


if __name__ == "__main__":
  context.log_level = "error"
  print(Solve(40, 4))
  io = remote("ioioioi.chal.crewc.tf", 1337, ssl=True)
  processing(io)
```
</TabItem>
</Tabs>
## HITCONCTF 2025 - pedantic

```python title="server.py"
#!/usr/bin/env python3
import hashlib
import json
import os
import secrets

from fastecdsa.curve import secp256k1
from fastecdsa.point import Point

p = secp256k1.p
q = secp256k1.q
G = secp256k1.G
field_bytes = (p.bit_length() + 7) // 8
scalar_bytes = (q.bit_length() + 7) // 8


def encode_point(pt: Point):
    return pt.x.to_bytes(field_bytes, "big") + pt.y.to_bytes(field_bytes, "big")


def decode_point(data: bytes):
    if len(data) != 2 * field_bytes:
        raise ValueError("Invalid point encoding")
    x = int.from_bytes(data[:field_bytes], "big")
    y = int.from_bytes(data[field_bytes:], "big")
    return Point(x, y, secp256k1)


def hash_point(pt: Point):
    h = hashlib.sha256(encode_point(pt)).digest()
    return int.from_bytes(h, "big") % q


def hash_points_to_scalars(pts: list[Point], n: int):
    s = sum([hash_point(pt) for pt in pts]) % q
    ret = []
    for _ in range(n):
        ret.append(s)
        s = (1337 * s + 7331) % q
    return ret


ProofType = list[tuple[Point, int]]


def prove(x: int, n: int) -> ProofType:
    rs = [secrets.randbelow(q) for _ in range(n)]
    Grs = [G * r for r in rs]
    cs = hash_points_to_scalars(Grs, n)
    zs = [(r + c * x) % q for r, c in zip(rs, cs)]
    return list(zip(Grs, zs))


def verify(Y: Point, proof: ProofType):
    Grs, zs = zip(*proof)
    n = len(Grs)
    cs = hash_points_to_scalars(Grs, n)
    return all(G * z == Gr + Y * c for Gr, z, c in zip(Grs, zs, cs)) * n


def serialize_proof(proof: ProofType):
    return json.dumps([(encode_point(pt).hex(), z) for pt, z in proof])


def deserialize_proof(s: str) -> ProofType:
    return [(decode_point(bytes.fromhex(pt)), z) for pt, z in json.loads(s)]


def main():
    flag = os.environ.get("FLAG", "flag{test}")

    sk = int.from_bytes(hashlib.sha256(flag.encode()).digest(), "big") % q
    pk = G * sk

    print("Hey, I know the flag!")
    proof = prove(sk, 10)
    assert verify(pk, proof) == 10, "wtf"
    print("Here is the proof:")
    print(serialize_proof(proof))
    print("Do you know it too?")
    proof = deserialize_proof(input("proof:"))
    n = verify(pk, proof)
    if n >= 42:
        print("I am convined :D")
        print(f"Here is it: {flag}")
    elif n > 0:
        print("Hmm, not sure about that... :thinking:")
    else:
        print("I think you don't :(")


if __name__ == "__main__":
    main()
```

æœ€å–œæ¬¢çš„mapleå¸ˆå‚…çš„é¢˜ğŸ¥° ~~ä»Šå¹´mapleä½¬ä¼¼ä¹æœ‰ç‚¹å¿™ï¼Œå¾ˆä¹…ä¹‹å‰å°±å¬è¯´imaginaryCTFä»–éƒ½æ²¡æ¥å‡ºé¢˜...ä¸è¿‡è¿˜å¥½HITCONé‡Œè§åˆ°äº†~~

é¢˜ç›®å®ç°äº†ä¸€ä¸ªsecp256k1æ›²çº¿ä¸Šçš„ZKPåè®®ï¼Œä»¥åŠç›¸å…³å‚æ•°ï¼š
```python
p = secp256k1.p
q = secp256k1.q
G = secp256k1.G
```

ç„¶å`prove()`æ˜¯è¿™æ ·çš„ï¼š
```python
def prove(x: int, n: int) -> ProofType:
  rs = [secrets.randbelow(q) for _ in range(n)]
  Grs = [G * r for r in rs]
  cs = hash_points_to_scalars(Grs, n)
  zs = [(r + c * x) % q for r, c in zip(rs, cs)]
  return list(zip(Grs, zs))
```
å…¶ä¸­`hash_points_to_scalars()`ä¹Ÿæ˜¯ç”¨æ¥ç”Ÿæˆéšæœºæ•°çš„ï¼Œä¼šæŠŠæ‰€æœ‰çš„ $Gr_i$ å“ˆå¸Œåæ±‚å’Œå½“ä½œseedï¼Œseeding LCGå»ç”Ÿæˆä¸€ä¸²éšæœºæ•°ä½œä¸º$c_i$ã€‚

verifyé€»è¾‘åˆ™æ˜¯å¦‚ä¸‹ï¼š

$$
z_i*G == Gr_i+c_i*Y
$$

å…¶ä¸­æˆ‘ä»¬è¾“å…¥çš„æ˜¯ $z_i, Gr_i$ï¼Œ$Y$ æ»¡è¶³ $Y = x*G$ï¼Œ$x$ ä¸ºç§é’¥ï¼Œ$Y$ ä¸ºå…¬é’¥ã€‚

ZKPåè®®æœ¬èº«æ²¡ä»€ä¹ˆé—®é¢˜ï¼Œ`hash_points_to_scalars()`é‡Œçš„hashä¹Ÿæ˜¯SHA-256ï¼Œå‡ ä¹ä¹Ÿæ‰“ä¸åŠ¨ï¼Œæ‰€ä»¥å”¯ä¸€çš„ç–‘ç‚¹å°±æ˜¯è¿™ä¸ªLCGäº†ã€‚LCGè¯´å®è¯ä¹Ÿä¸æ˜¯å¾ˆèƒ½æ‰“ï¼Œæ¯•ç«Ÿæˆ‘ä»¬åªèƒ½æ§åˆ¶è¾“å…¥çš„$Gr_i$ï¼Œ
è¿™äº›ç‚¹è¿˜å¾—æ±‚å’Œhashä¹‹åæ‰èƒ½å½“ä½œseedã€‚

import {Aside, Spoiler} from 'astro-pure/user';

<Aside type='note'>
é€€ä¸€æ­¥æ¥è¯´ï¼Œå°±ç®—æœ‰åŠæ³•ç›´æ¥æ§åˆ¶seedä¹Ÿä¸èƒ½å¾ˆéšå¿ƒæ‰€æ¬²åœ°æ§åˆ¶è¾“å‡ºï¼Œæ¯•ç«Ÿéš”äº†ä¸€å±‚LCGå‘¢
</Aside>

æˆ‘ä»¬çŸ¥é“æœ‰äº›LCGæ˜¯å­˜åœ¨è½¨é“/ä¸åŠ¨ç‚¹çš„â€”â€”å¯¹äºç‰¹å®šçš„seedï¼ŒLCGçš„è¿­ä»£è¾“å‡ºå¯èƒ½ä¼šè¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œç”šè‡³æ˜¯å›ºå®šä¸å˜çš„å€¼ã€‚è¿™å…¶å®è·ŸåŠ¨åŠ›ç³»ç»Ÿå¾ˆåƒã€‚æœ¬é¢˜çš„LCGåŒæ ·å­˜åœ¨ä¸åŠ¨ç‚¹ã€‚
å› æ­¤å¯¹äºæˆ‘ä»¬æ¥è¯´ï¼Œæœ€æœ´ç´ çš„æƒ³æ³•å°±æ˜¯æ§åˆ¶è¾“å…¥ä½¿å¾—seedä¸ºä¸åŠ¨ç‚¹ï¼Œè¿™æ ·LCGçš„è¾“å‡ºæ¯”è¾ƒç®€å•ï¼Œåé¢åšé¢˜å¤§æ¦‚ç‡ä¹Ÿä¼šç®€åŒ–ä¸€ç‚¹ã€‚

è¾“å…¥çš„seedæ˜¯ä¸åŠ¨ç‚¹ï¼Œ$z_i$ä¹Ÿæ˜¯æˆ‘ä»¬æŒ‡å®šçš„ï¼Œé‚£ä¹ˆ$Gr_i$ç›´æ¥å°±èƒ½è®¡ç®—å‡ºæ¥ã€‚é—®é¢˜åœ¨äºï¼Œæ€ä¹ˆç¡®ä¿è¿™äº›$Gr_i$ç»è¿‡hashæ±‚å’Œä¹‹ååˆšå¥½å°±ç­‰äºä¸åŠ¨ç‚¹seedå‘¢ï¼Ÿ

ç›´è§‰ä¸Šä¼šè§‰å¾—æœ‰ç‚¹åƒLLL<Spoiler>çœ‹è§çº¿æ€§å…³ç³»å°±æƒ³æ ¼è¯´æ˜¯</Spoiler>ï¼Œå› ä¸ºæˆ‘ä»¬å…¶å®åªéœ€è¦æ‰¾åˆ°è¿™ä¹ˆä¸€ç»„ç³»æ•°${a_i}$ä½¿å¾—$\Sigma a_i * hash(Gr_i)$ç­‰äºä¸åŠ¨ç‚¹seedå³å¯ï¼Œåˆ°æ—¶å€™æˆ‘ä»¬ä¼ å…¥$Gr_i$çš„æ—¶å€™æŠŠå¯¹åº”çš„$Gr_i$å’Œ$z_i$é‡å¤$a_i$æ¬¡å°±å¥½äº†ã€‚

å·æ‡’ä¸æƒ³å†™expäº†ï¼Œæ”¾ä¸ªmapleå†™çš„ç„¶åè·‘è·¯ğŸ¥°

<Tabs>
<TabItem label='solve.py'>
```python
from sage.all import *
import gzip
import hashlib

from binteger import Bin
from server import (
    G,
    deserialize_proof,
    hash_point,
    hash_points_to_scalars,
    q,
    scalar_bytes,
    serialize_proof,
    verify,
)
from lll_cvp import affine_cvp, qary_lattice

from pwn import process, remote

# io = process(["python", "server.py"])
# io = remote("localhost", 1337)
io = remote("pedantic.chal.hitconctf.com", 1337)
io.recvuntil(b"proof:\n")
proof = deserialize_proof(io.recvlineS().strip())

Grs, zs = zip(*proof)
cs = hash_points_to_scalars(Grs, len(Grs))
Y = (G * zs[0] - Grs[0]) * pow(cs[0], -1, q)
print(Y)  # use this as input to the golang solver to get solution_with_z.txt

F = GF(q)
a = F(1337)
b = F(7331)
c = int(-b / (a - 1))  # fixed opint
assert a * c + b == c


m = 64
zs = list(range(m))
Grs = [G * z - Y * c for z in zs]
hs = [hash_point(Gr) for Gr in Grs]
L = matrix(F, hs)
rhs = vector(F, [c])

# we want to find a short, positive solution to L * ? = rhs
s0 = L.solve_right(rhs).change_ring(ZZ)
ker = L.right_kernel_matrix()
# the solution should be positive, so we find a vector close to 20
t = affine_cvp(s0, qary_lattice(ker, q), vector([20] * m))
print(t, sum(t))
assert L * t == rhs
assert all([x >= 0 for x in t])

Grs = sum([[Gr] * x for Gr, x in zip(Grs, t)], [])
zs = sum([[z] * x for z, x in zip(zs, t)], [])

proof = list(zip(Grs, zs))
assert verify(Y, proof) == sum(t)

io.sendline(serialize_proof(proof).encode())
print(io.recvallS().strip())
```
</TabItem>
</Tabs>