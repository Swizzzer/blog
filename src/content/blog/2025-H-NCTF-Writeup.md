---
title: 2025 H&NCTF Writeup
tags: ["CTF", "Crypto"]
category: Writeups
publishDate: 2025-06-08
heroImage: {src: "assets/image-27.png"}
description: "è·Ÿé˜Ÿå‹åˆåŠ›AKäº†Cryptoã€Miscã€Pwnå’ŒForensicsï¼Œæœ€ç»ˆæˆåŠŸæ‹¿ä¸‹rank #1"
---

é˜Ÿå‹çš„WP:

[2025 HNCTF Webæ–¹å‘å…¨éƒ¨é¢˜è§£](https://sakuraraindrop.github.io/2025/06/08/HNCTF2025/)

[2025 HNCTF Reverse - F**K](https://let.doctxing.win/#/blogs/ctfreverse001/)


# Crypto

## æ•°æ®å¤„ç†

`task`

```python
from Crypto.Util.number import bytes_to_long
import random
flag = b"H&NCTF{}"

btl = str(bytes_to_long(flag))
lowercase = '0123456789' 
uppercase = '7***4****5' 

table = ''.maketrans(lowercase, uppercase) 

new_flag = btl.translate(table)
n = 2 ** 512

m = random.randint(2, n - 1) | 1


c = pow(m, int(new_flag), n)
print('m = ' + str(m))
print('c = ' + str(c))
# m = 5084057673176634704877325918195984684237263100965172410645544705367004138917087081637515846739933954602106965103289595670550636402101057955537123475521383
# c = 2989443482952171039348896269189568991072039347099986172010150242445491605115276953489889364577445582220903996856271544149424805812495293211539024953331399
```

DLP+çˆ†ç ´ï¼Œæ‡’å¾—å†™ä»£ç ï¼Œç›´æ¥æ‰”ç»™AIå†™ã€‚

`exp`

```python
from sage.all import *
m = 5084057673176634704877325918195984684237263100965172410645544705367004138917087081637515846739933954602106965103289595670550636402101057955537123475521383
c = 2989443482952171039348896269189568991072039347099986172010150242445491605115276953489889364577445582220903996856271544149424805812495293211539024953331399
n = 2**512
F = Zmod(n)
c = F(c)
m = F(m)
c.log(m)
new_flag_str = "3282248010524512146638712359816289396373430161050484501341123570760619381019795910712610762203934445754701"
from Crypto.Util.number import bytes_to_long, long_to_bytes
import itertools

lowercase = '0123456789' 
masked = '7***4****5'

new_flag = "3282248010524512146638712359816289396373430161050484501341123570760619381019795910712610762203934445754701"  # è¯·è¾“å…¥ä½ å·²çŸ¥çš„new_flag

known_map = {}
for i, char in enumerate(masked):
    if char != '*':
        known_map[lowercase[i]] = char

unknown = [i for i, char in enumerate(masked) if char == '*']
unknown_digits = [lowercase[i] for i in unknown]
known_digits = [masked[i] for i in range(10) if masked[i] != '*']

digits_cands = [d for d in '0123456789' if d not in known_digits]
permutations_cands = itertools.permutations(digits_cands, len(unknown))

for perm in permutations_cands:
    curr_map = known_map.copy()
    for i, pos in enumerate(unknown):
        curr_map[lowercase[pos]] = perm[i]
    
    btl_cand = ""
    for char in new_flag:
        for k, v in curr_map.items():
            if v == char:
                btl_cand += k
                break
        else:
            btl_cand += char

    try:
        smp = int(btl_cand)
        flag = long_to_bytes(smp)
        
        if flag.startswith(b"H&NCTF{") and flag.endswith(b"}") and all(32 <= b <= 126 for b in flag):
            print("ğŸ‰ğŸ‰ğŸ‰")
            print(f"{flag.decode()}")
    except:
        continue

# ğŸ‰ğŸ‰ğŸ‰
# H&NCTF{cut_cut_rrioajtfijrwegeriogjiireigji}
```

## ezfactor

`task`

```python
from Crypto.Util.number import *
import uuid

rbits = 248
Nbits = 1024

p = getPrime(Nbits // 2)
q = getPrime(Nbits // 2)
N = p * q
r = getPrime(rbits)
hint = getPrime(Nbits // 2) * p + r
R = 2^rbits
e=0x10001
n=p*q
phi=(p-1)*(q-1)
flag = b'H&NCTF{' + str(uuid.uuid4()).encode() + b'}'
m=bytes_to_long(flag)
c=pow(m,e,n)
print("N=",N)
print("hint=",hint)
print(c)
# N= 155296910351777777627285876776027672037304214686081903889658107735147953235249881743173605221986234177656859035013052546413190754332500394269777193023877978003355429490308124928931570682439681040003000706677272854316717486111569389104048561440718904998206734429111757045421158512642953817797000794436498517023
# hint= 128897771799394706729823046048701824275008016021807110909858536932196768365642942957519868584739269771824527061163774807292614556912712491005558619713483097387272219068456556103195796986984219731534200739471016634325466080225824620962675943991114643524066815621081841013085256358885072412548162291376467189508
# c=32491252910483344435013657252642812908631157928805388324401451221153787566144288668394161348411375877874802225033713208225889209706188963141818204000519335320453645771183991984871397145401449116355563131852618397832704991151874545202796217273448326885185155844071725702118012339804747838515195046843936285308

```

ACDé—®é¢˜ã€‚rçœ‹ä¸€çœ¼å°±çŸ¥é“æ˜¯ä¸ªmod pçš„å°æ ¹ï¼Œåªä¸è¿‡ç•Œå¡å¾—è›®ç´§çš„ã€‚Coppersmithè°ƒepsilonåˆ°0.01ï¼Œå†ç”¨flatteråŠ é€Ÿä¸€ä¸‹æ ¼è§„çº¦ï¼ŒR5 5600xä¸Šä¹Ÿèƒ½30så†…å‡ºç­”æ¡ˆã€‚

`exp`

```python
from sage.all import *
from re import findall
from subprocess import check_output
from Crypto.Util.number import *


def flatter(M):
    # compile https://github.com/keeganryan/flatter and put it in $PATH
    z = "[[" + "]\n[".join(" ".join(map(str, row)) for row in M) + "]]"
    ret = check_output(["flatter"], input=z.encode())
    return matrix(M.nrows(), M.ncols(), map(int, findall(b"-?\\d+", ret)))


def small_roots(self, X=None, beta=0.5, epsilon=None, **kwds):
    from sage.misc.verbose import verbose
    from sage.matrix.constructor import Matrix
    from sage.rings.real_mpfr import RR

    N = self.parent().characteristic()

    if not self.is_monic():
        raise ArithmeticError("Polynomial must be monic.")

    beta = RR(beta)
    if beta <= 0.0 or beta > 1.0:
        raise ValueError("0.0 < beta <= 1.0 not satisfied.")

    f = self.change_ring(ZZ)

    P, (x,) = f.parent().objgens()

    delta = f.degree()

    if epsilon is None:
        epsilon = beta / 8
    verbose("epsilon = %f" % epsilon, level=2)

    m = max(beta**2 / (delta * epsilon), 7 * beta / delta).ceil()
    verbose("m = %d" % m, level=2)

    t = int((delta * m * (1 / beta - 1)).floor())
    verbose("t = %d" % t, level=2)

    if X is None:
        X = (0.5 * N ** (beta**2 / delta - epsilon)).ceil()
    verbose("X = %s" % X, level=2)

    # we could do this much faster, but this is a cheap step
    # compared to LLL
    g = [x**j * N ** (m - i) * f**i for i in range(m) for j in range(delta)]
    g.extend([x**i * f**m for i in range(t)])  # h

    B = Matrix(ZZ, len(g), delta * m + max(delta, t))
    for i in range(B.nrows()):
        for j in range(g[i].degree() + 1):
            B[i, j] = g[i][j] * X**j
    print("[+] Starting flatter...")
    B = flatter(B)
    # B = B.LLL()

    f = sum([ZZ(B[0, i] // X**i) * x**i for i in range(B.ncols())])
    R = f.roots()

    ZmodN = self.base_ring()
    roots = set([ZmodN(r) for r, m in R if abs(r) <= X])
    Nbeta = N**beta
    return [root for root in roots if N.gcd(ZZ(self(root))) >= Nbeta]

N = 155296910351777777627285876776027672037304214686081903889658107735147953235249881743173605221986234177656859035013052546413190754332500394269777193023877978003355429490308124928931570682439681040003000706677272854316717486111569389104048561440718904998206734429111757045421158512642953817797000794436498517023
hint = 128897771799394706729823046048701824275008016021807110909858536932196768365642942957519868584739269771824527061163774807292614556912712491005558619713483097387272219068456556103195796986984219731534200739471016634325466080225824620962675943991114643524066815621081841013085256358885072412548162291376467189508
c = 32491252910483344435013657252642812908631157928805388324401451221153787566144288668394161348411375877874802225033713208225889209706188963141818204000519335320453645771183991984871397145401449116355563131852618397832704991151874545202796217273448326885185155844071725702118012339804747838515195046843936285308

e = 0x10001

R = 2**248

P = PolynomialRing(Zmod(N), "x")
x = P.gen()
# y + (hint - R) % p == 0
g = hint - x
g = g.monic()

roots = small_roots(g, X=R, beta=0.499, epsilon=0.01)

if roots:
    y0 = roots[0]
    r = int(y0)
    print("Recovered r:", r)
    
    if isPrime(int(r)):
        print("r is prime.")
        p = gcd(N, hint - r)
        if p > 1 and p < N:
            q = N // p
            print("Recovered p:", p)
            print("Recovered q:", q)
            
            phi = (p - 1) * (q - 1)
            d = pow(e, -1, phi)
            m = pow(c, d, N)
            flag = bytes.fromhex(hex(m)[2:])
            print("Flag:", flag)
        else:
            print("Failed to factor N.")
    else:
        print("r is not prime.")
else:
    print("No roots found. Adjust parameters or try different epsilon.")
```

## ezfactor-pro

`task`

```python
from Crypto.Util.number import *
from Crypto.Util.Padding import *
from gmssl.sm4 import CryptSM4, SM4_ENCRYPT
from hashlib import sha256
from random import *
import uuid
rbits = 252
Nbits = 1024

p = getPrime(Nbits//2)
q = getPrime(Nbits//2)
N = p*q
r = getPrime(rbits)
hint = getPrime(Nbits// 2)*p+r
R = 2^rbits
flag = b'H&NCTF{'+str(uuid.uuid4()).encode()+b'}'

leak=p*q*r
r_bytes = long_to_bytes(leak)
iv = r_bytes[:16] if len(r_bytes) >= 16 else r_bytes + b'\0'*(16-len(r_bytes))
key = sha256(str(p + q + r).encode()).digest()[:16] 
crypt_sm4 = CryptSM4()
crypt_sm4.set_key(key, SM4_ENCRYPT)
padded_flag = pad(flag, 16)
c = crypt_sm4.crypt_cbc(iv, padded_flag)
print("N=",N)
print("hint=",hint)
print(c)
#N = 133196604547992363575584257705624404667968600447626367604523982016247386106677898877957513177151872429736948168642977575860754686097638795690422242542292618145151312000412007125887631130667228632902437183933840195380816196093162319293698836053406176957297330716990340998802156803899579713165154526610395279999
#hint = 88154421894117450591552142051149160480833170266148800195422578353703847455418496231944089437130332162458102290491849331143073163240148813116171275432632366729218612063176137204570648617681911344674042091585091104687596255488609263266272373788618920171331355912434290259151350333219719321509782517693267379786
#c = 476922b694c764725338cca99d99c7471ec448d6bf60de797eb7cc6e71253221035eb577075f9658ac7f1a40747778ac261787baad21ee567256872fa9400c37
```

è·Ÿä¸Šä¸€é¢˜ä¸åŒçš„ç‚¹åœ¨äºç•Œæ›´å¤§äº†ç‚¹ã€‚çˆ†ç ´å‡ ä¸ªbitså†å»Coppersmithå°±å¥½ã€‚

`exp`

```python
from sage.all import *
from re import findall
from subprocess import check_output
from Crypto.Util.number import *
import time

def flatter(M):
    # compile https://github.com/keeganryan/flatter and put it in $PATH
    z = "[[" + "]\n[".join(" ".join(map(str, row)) for row in M) + "]]"
    env = os.environ.copy()
    env['OMP_NUM_THREADS'] = '8'  # MacBookä¸Šæ§åˆ¶çº¿ç¨‹æ•°é‡, é¿å…è°ƒåº¦åˆ°å°æ ¸ä¸Š
    ret = check_output(["flatter"], input=z.encode(), env=env)
    return matrix(M.nrows(), M.ncols(), map(int, findall(rb"-?\d+", ret)))


def small_roots(self, X=None, beta=0.5, epsilon=None, **kwds):
    from sage.misc.verbose import verbose
    from sage.matrix.constructor import Matrix
    from sage.rings.real_mpfr import RR

    N = self.parent().characteristic()

    if not self.is_monic():
        raise ArithmeticError("Polynomial must be monic.")

    beta = RR(beta)
    if beta <= 0.0 or beta > 1.0:
        raise ValueError("0.0 < beta <= 1.0 not satisfied.")

    f = self.change_ring(ZZ)

    P, (x,) = f.parent().objgens()

    delta = f.degree()

    if epsilon is None:
        epsilon = beta / 8
    verbose("epsilon = %f" % epsilon, level=2)

    m = max(beta**2 / (delta * epsilon), 7 * beta / delta).ceil()
    verbose("m = %d" % m, level=2)

    t = int((delta * m * (1 / beta - 1)).floor())
    verbose("t = %d" % t, level=2)

    if X is None:
        X = (0.5 * N ** (beta**2 / delta - epsilon)).ceil()
    verbose("X = %s" % X, level=2)

    # we could do this much faster, but this is a cheap step
    # compared to LLL
    g = [x**j * N ** (m - i) * f**i for i in range(m) for j in range(delta)]
    g.extend([x**i * f**m for i in range(t)])  # h

    B = Matrix(ZZ, len(g), delta * m + max(delta, t))
    for i in range(B.nrows()):
        for j in range(g[i].degree() + 1):
            B[i, j] = g[i][j] * X**j
    print("[+] Starting flatter...")
    
    # æŠŠSagemathåŸç‰ˆLLLæ¢æˆflatterä»¥åŠ é€Ÿ
    B = flatter(B)
    # B = B.LLL()

    f = sum([ZZ(B[0, i] // X**i) * x**i for i in range(B.ncols())])
    R = f.roots()

    ZmodN = self.base_ring()
    roots = set([ZmodN(r) for r, m in R if abs(r) <= X])
    Nbeta = N**beta
    return [root for root in roots if N.gcd(ZZ(self(root))) >= Nbeta]

def copp_factor(N, hint, leak=4):
    for tb in range(1 << leak)[::-1]:
        print("copp", tb, int(time.time()))
        shift = 252 - leak
        P = Zmod(N)["x"]
        x = P.gen()
        f = (hint - (tb << shift) - x).monic()
        X = 2 ** (252 - leak)
        beta = 0.499
        eps = 0.01
        # rs = f.small_roots(X=X, beta=beta, epsilon=eps)
        rs = small_roots(f, X=X, beta=beta, epsilon=eps)
        if len(rs):
            return (tb << shift) + int(rs[0])
N = 133196604547992363575584257705624404667968600447626367604523982016247386106677898877957513177151872429736948168642977575860754686097638795690422242542292618145151312000412007125887631130667228632902437183933840195380816196093162319293698836053406176957297330716990340998802156803899579713165154526610395279999
hint = 88154421894117450591552142051149160480833170266148800195422578353703847455418496231944089437130332162458102290491849331143073163240148813116171275432632366729218612063176137204570648617681911344674042091585091104687596255488609263266272373788618920171331355912434290259151350333219719321509782517693267379786

copp_factor(N, hint, 4)
"""then we can get flag
"""
from Crypto.Util.number import *
from Crypto.Util.Padding import unpad
from gmssl.sm4 import CryptSM4, SM4_DECRYPT
from hashlib import sha256

r = 7166351305785506670352015492214713707534657162937963088592442157834795391917
N = 133196604547992363575584257705624404667968600447626367604523982016247386106677898877957513177151872429736948168642977575860754686097638795690422242542292618145151312000412007125887631130667228632902437183933840195380816196093162319293698836053406176957297330716990340998802156803899579713165154526610395279999
hint = 88154421894117450591552142051149160480833170266148800195422578353703847455418496231944089437130332162458102290491849331143073163240148813116171275432632366729218612063176137204570648617681911344674042091585091104687596255488609263266272373788618920171331355912434290259151350333219719321509782517693267379786
c = bytes.fromhex(
    "476922b694c764725338cca99d99c7471ec448d6bf60de797eb7cc6e71253221035eb577075f9658ac7f1a40747778ac261787baad21ee567256872fa9400c37"
)

p = GCD(hint - r, N)
if p == 1 or p == N or N % p != 0:
    raise ValueError("Failed to factorize N with given r")
q = N // p

leak = N * r
r_bytes = long_to_bytes(leak)
iv = r_bytes[:16] if len(r_bytes) >= 16 else r_bytes + b"\0" * (16 - len(r_bytes))
s = p + q + r
key = sha256(str(s).encode()).digest()[:16]

crypt_sm4 = CryptSM4()
crypt_sm4.set_key(key, SM4_DECRYPT)
decrypted = crypt_sm4.crypt_cbc(iv, c)
plaintext = unpad(decrypted, 16)

print("Decrypted Flag:", plaintext.decode())

```

> Update: 2025.06.15

:::note
èµ›åå®éªŒäº†ä¸€ä¸‹å‘ç°æˆ‘è¿™ç§è§£æ³•å¾ˆoverkillï¼ŒCoppersmithå‚æ•°å¼€åˆ°0.006ä¹‹åå³ä½¿ä¸ç”¨çˆ†bitsä¹Ÿèƒ½ç›´æ¥å‡ºğŸ¤£è€Œåœ¨flatterçš„åŠ æŒä¸‹ï¼Œå³ä½¿betaå¼€åˆ°è¿™ä¹ˆå°ç”¨æ—¶ä¹Ÿå¾ˆçŸ­
:::

## ä¸ºä»€ä¹ˆå‡ºé¢˜äººçš„rsaæ€»æ˜¯ez

`task`

```python
#!/usr/bin/sage

#part 1

def pad(flag, bits=1024):
    pad = os.urandom(bits//8 - len(flag))
    return int.from_bytes(flag + pad, "big")

p = random_prime(2**1024)
q = random_prime(2**1024)
a = randint(0, 2**1024)
b = randint(0, 2**1024)
n = p * q
e = 0x10001
flag = b''
m = pad(flag)
assert m < n

c = pow(m, e, n)

print(f"c={c}")
print(f"n={n}")
print(f"h1={p + b * q}")
print(f"h2={a * p + q}")
# c=13148687178480196374316468746303529314940770955906554155276099558796308164996908275540972246587924459788286109602343699872884525600948529446071271042497049233796074202353913271513295267105242313572798635502497823862563815696165512523074252855130556615141836416629657088666030382516860597286299687178449351241568084947058615139183249169425517358363928345728230233160550711153414555500038906881581637368920188681358625561539325485686180307359210958952213244628802673969397681634295345372096628997329630862000359069425551673474533426265702926675667531063902318865506356674927615264099404032793467912541801255735763704043
# n=13718277507497477508850292481640653320398820265455820215511251843542886373380880887850571647060788265498378060163112689840208264538965960596605641194331300743676780910818492860412739541418029075802834265712602393103809065720527365081016381358333378953245379751008531500896923727040455566953960991908174586311899809864209624888469263612475732913062035036254077225370843701146080145441104733074178115602425412116325647598625157922655504918118208783230138448694045386019901732846478340735331718476554208157393418221315041837392020742062275999319586357229583509788489495876723122993592623230858393165458733055504467513549
# h1=6992022576367328281523272055384380182550712894467837916200781058620282657859189270338635886912232754034211897894637971546032107000253692739473463119025570291091085702056938901846349325941043398928197991115231668917435951127329817379935880511925882734157491821315858319170121031835598580384038723788681860763814776365440362143661999054338470989558459179388468943933975861549233231199667742564080001256192881732567616103760815633265325456143601649393547666835326272408622540044065067528568675569233240785553062685974593620235466519632833169291153478793523397788719000334929715524989845012633742964209311952378479134661
# h2=16731800146050995761642066586565348732313856101572403535951688869814016691871958158137790504490910445304384109605408840493227057830017039824412834989258703833576252634055087138315434304691218949240382395879124201923060510497916818961571111218224960267593032380037212325935576750663442553781924370849537501656957488833521657563900462052017695599020610911371304659875887924695896434699048696392210066253577839887826292569913713802634067508141124685789817330268562127695548527522031774601654778934513355315628270319037043809972087930951609429846675450469414212384044849089372435124609387061864545559812994515828333828939

#part 2

from Crypto.Util.number import *
from gmpy2 import *
a = random_prime()
b = random_prime()
g = random_prime()
h = 2*g*a*b+a+b
while not is_prime(h):
    a = random_prime()
    b = random_prime()
    g = random_prime()
    h = 2*g*a*b+a+b
N = 2*h*g+1
e from part1's flag
flag=b''
c=pow(bytes_to_long(flag),e,N)
print(N)
print(g)
print(c)
#N=10244621233521168199001177069337072125430662416754674144307553476569744623474797179990380824494968546110022341144527766891662229403969035901337876527595841503498459533492730326942662450786522178313517616168650624224723066308178042783540825899502172432884573844850572330970359712379107318586435848029783774998269247992706770665069866338710349292941829996807892349030660021792813986069535854445874069535737849684959397062724387110903918355074327499675776518032266136930264621047345474782910332154803497103199598761422179303240476950271702406633802957400888398042773978322395227920699611001956973796492459398737390290487
#g=2296316201623391483093360819129167852633963112610999269673854449302228853625418585609211427788830598219647604923279054340009043347798635222302374950707
#c=7522161394702437062976246147354737122573350166270857493289161875402286558096915490526439656281083416286224205494418845652940140144292045338308479237214749282932144020368779474518032067934302376430305635297260147830918089492765917640581392606559936829974748692299762475615766076425088306609448483657623795178727831373194757182797030376302086360751637238867384469269953187938304369668436238848537646544257504724753333177938997524154486602644412199535102323238852958634746165559537630341890450666170836721803871120344373143081664567068672230842855208267929484000179260292518351155693154372172449820053764896414799137097
```
å‰åŠéƒ¨åˆ†ç»™äº† $h_1=p+b q, h_2=a p+q$ ï¼Œå…¶ä¸­ $a, b, p, q$ éƒ½æ˜¯ 1024 bits çš„ã€‚
ä»¤

$$
f(x, y)=(h_1-x)(h_2-y)
$$

å¯çŸ¥ $f(p, q) \equiv 0(\bmod n)$ï¼Œå±•å¼€åå°±æœ‰

å› æ­¤æœ‰ï¼š
$$
h_1 h_2-q h_2-p h_1+p q \equiv h_1 h_2-q h_2-p h_1 \equiv 0 \quad(\bmod n)
$$

å…¶ä¸­ $h_1, h_2, n$ å·²çŸ¥ï¼Œæ‰€ä»¥LLLä¸€ä¸‹å¤§æ¦‚å°±æœ‰på’Œqã€‚

é…å¹³æ ¼æ¯”è¾ƒéº»çƒ¦ï¼Œæ¨èç”¨maple3142ä½¬çš„[lll_cvp](https://github.com/maple3142/lll_cvp)ï¼Œå¥½ç”¨çˆ±ç”¨ã€‚

ååŠæ®µæ˜¯Common Prime RSAå·²çŸ¥gçš„æƒ…å†µï¼Œæœ‰è®ºæ–‡å¯å‚è€ƒä½†æ˜¯æˆ‘ç›´æ¥å¯¹ç€è®ºæ–‡æ“å‡ºæ¥çš„expç‚¸å†…å­˜äº†...

> è¿˜æ˜¯ç åŠ›ä¸è¶³

æ£€ç´¢ä¸€ç•ªå‘ç°å‡ ä¹æ˜¯MRCTF 2021 - Common Prime RSAçš„åŸé¢˜ï¼Œå»deebatoçš„[åšå®¢](https://d33b4t0.com/MRCTF2021WP/)æŠ„ä¸ªexpå›æ¥å°±èƒ½è§£å†³ã€‚ä»¥åŠï¼Œå‡ºé¢˜äººä½ æ²¡æœ‰å‘ç°ä½ çš„ä»£ç å†™çš„æ˜¯æ­»å¾ªç¯å—ğŸ˜¡

`exp`

```python
from sage.all import *
from Crypto.Util.number import *
from lll_cvp import solve_inequality # https://github.com/maple3142/lll_cvpï¼Œå¥½ç”¨çˆ±ç”¨

c=13148687178480196374316468746303529314940770955906554155276099558796308164996908275540972246587924459788286109602343699872884525600948529446071271042497049233796074202353913271513295267105242313572798635502497823862563815696165512523074252855130556615141836416629657088666030382516860597286299687178449351241568084947058615139183249169425517358363928345728230233160550711153414555500038906881581637368920188681358625561539325485686180307359210958952213244628802673969397681634295345372096628997329630862000359069425551673474533426265702926675667531063902318865506356674927615264099404032793467912541801255735763704043
n=13718277507497477508850292481640653320398820265455820215511251843542886373380880887850571647060788265498378060163112689840208264538965960596605641194331300743676780910818492860412739541418029075802834265712602393103809065720527365081016381358333378953245379751008531500896923727040455566953960991908174586311899809864209624888469263612475732913062035036254077225370843701146080145441104733074178115602425412116325647598625157922655504918118208783230138448694045386019901732846478340735331718476554208157393418221315041837392020742062275999319586357229583509788489495876723122993592623230858393165458733055504467513549
h1=6992022576367328281523272055384380182550712894467837916200781058620282657859189270338635886912232754034211897894637971546032107000253692739473463119025570291091085702056938901846349325941043398928197991115231668917435951127329817379935880511925882734157491821315858319170121031835598580384038723788681860763814776365440362143661999054338470989558459179388468943933975861549233231199667742564080001256192881732567616103760815633265325456143601649393547666835326272408622540044065067528568675569233240785553062685974593620235466519632833169291153478793523397788719000334929715524989845012633742964209311952378479134661
h2=16731800146050995761642066586565348732313856101572403535951688869814016691871958158137790504490910445304384109605408840493227057830017039824412834989258703833576252634055087138315434304691218949240382395879124201923060510497916818961571111218224960267593032380037212325935576750663442553781924370849537501656957488833521657563900462052017695599020610911371304659875887924695896434699048696392210066253577839887826292569913713802634067508141124685789817330268562127695548527522031774601654778934513355315628270319037043809972087930951609429846675450469414212384044849089372435124609387061864545559812994515828333828939


L = matrix([[n, 0, 0, 0], [h1 * h2, 1, 0, 0], [-h2, 0, 1, 0], [-h1, 0, 0, 1]])
lb = [0, 1, 0, 0]
ub = [0, 1, 2**1024, 2**1024]
sol = solve_inequality(L, lb, ub)
_, _, p, q = map(int, sol)
assert p * q == n
phi = (p - 1) * (q - 1)
d = pow(0x10001, -1, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
e2 = 81733668723981020451323 # #BubbleBabbleç¼–ç 
# Copied from deebato
# the king of Cryptography!
# https://d33b4t0.com/MRCTF2021WP/

from sage.all import *
from gmpy2 import iroot
n=10244621233521168199001177069337072125430662416754674144307553476569744623474797179990380824494968546110022341144527766891662229403969035901337876527595841503498459533492730326942662450786522178313517616168650624224723066308178042783540825899502172432884573844850572330970359712379107318586435848029783774998269247992706770665069866338710349292941829996807892349030660021792813986069535854445874069535737849684959397062724387110903918355074327499675776518032266136930264621047345474782910332154803497103199598761422179303240476950271702406633802957400888398042773978322395227920699611001956973796492459398737390290487
g=2296316201623391483093360819129167852633963112610999269673854449302228853625418585609211427788830598219647604923279054340009043347798635222302374950707

beta = 2*g
s = (n-1)//beta
u = s//beta
v = s% beta

# åŸè®ºæ–‡çš„ç•Œå¤ªå®½äº†ï¼Œå¯¹ç€æ“çš„expä¼šç‚¸å†…å­˜
left = (2*int(sqrt(n))//beta-2-v)//beta
right = (3*int(sqrt(2)*sqrt(n))//(2*beta) - 2 - v )//beta
print(left)
print(right)
print(right-left)
print(iroot(right-left,2))
D = iroot(right - left , 2)[0] + 1
b = pow(2 , beta, n)
dic = {}
base = pow(b , left , n)
diff = pow(b , D , n)
for i in range(D+1):
    temp = base & 0xfffffffffff
    if temp in dic:
        print(i)
    dic[temp] = i
    base *= diff 
    base %= n
print('baby step done')
base = pow(b , u , n)
diff = inverse(b , n)

for i in range(D + 1):
    temp = base & 0xfffffffffff
    if temp in dic:
        print(i , dic[temp])
    base *= diff
    base %= n
c=left+91*D+705
xy = u - c
x_y = v + c * beta
temp = iroot(x_y**2 - 4 * xy , 2)[0]
x = (x_y +temp) // 2
y = (x_y - temp) //2
p = x * beta + 1
q = y * beta + 1
print(p,q)
assert isPrime(p) and isPrime(q)
print(p*q == n)
phi = (p-1)*(q-1)
d = inverse(e2, phi)
c = 7522161394702437062976246147354737122573350166270857493289161875402286558096915490526439656281083416286224205494418845652940140144292045338308479237214749282932144020368779474518032067934302376430305635297260147830918089492765917640581392606559936829974748692299762475615766076425088306609448483657623795178727831373194757182797030376302086360751637238867384469269953187938304369668436238848537646544257504724753333177938997524154486602644412199535102323238852958634746165559537630341890450666170836721803871120344373143081664567068672230842855208267929484000179260292518351155693154372172449820053764896414799137097
print(long_to_bytes(pow(c,d,n)))
# b'flag{I wish you success in your cryptography career}'
```

> äº‹åçœ‹äº†laä½¬çš„[åšå®¢](https://lazzzaro.github.io/2025/06/08/match-2025H&NCTF/#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84rsa%E6%80%BB%E6%98%AFez)ï¼ŒåŸæ¥æŠŠç½‘ä¸Šå·²æœ‰çš„expé‡Œgammaæ”¹æˆæœ‰ç†æ•°å°±å¥½äº†...èµ›ä¸­æˆ‘ç›´æ¥å–äº†ä¸¤ä½å°æ•°ä¸€ç›´æ‰“ä¸é€šQQ


## lcgp

ç­¾åˆ°é¢˜ï¼Œä¸æƒ³çœ‹ä¹Ÿä¸æƒ³æ€è€ƒï¼Œæ‰”ç»™AIä¸€æŠŠæ¢­:P

`task`

```python
from Crypto.Util.number import *
import gmpy2
import random
n = getPrime(1024)
flag = b'H&NCTF{' + str(uuid.uuid4()).encode() + b'}'
flag=bytes_to_long(flag)
e = 2024
c=pow(e, flag, n)

class LCG:
    def __init__(self, seed, a, b, m):
        self.seed = seed
        self.a = a
        self.b = b
        self.m = m

    def generate(self):
        self.seed = (self.a * self.seed + self.b) % self.m
        return self.seed

lcg = LCG(c, getPrime(256), getPrime(256), getPrime(2048))
random = [lcg.generate() for _ in range(5)]

print(random)
print("n=",n)
#[11250327355112956284720719987943941825496074893551827972877616718074592862130806975889275745497426515405562887727117008818863728803549848574821067056997423443681347885027000632462241968640893471352200125748453396098854283137158609264944692129301617338233670002547470932851350750870478630955328653729176440142198779254117385657086615711880537380965161180532127926250520546846863536247569437, 1289730679860726245234376434590068355673648326448223956572444944595048952808106413165882424967688302988257332835229651422892728384363094065438370663362237241013242843898967355558977974152917458085812489310623200114007728021151551927660975648884448177346441902806386690751359848832912607313329587047853601875294089502467524598036474193845319703759478494109845743765770254308199331552085163360820459311523382612948322756700518669154345145757700392164795583041949318636, 147853940073845086740348793965278392144198492906678575722238097853659884813579087132349845941828785238545905768867483183634111847434793587821166882679621234634787376562998606494582491550592596838027522285263597247798608351871499848571767008878373891341861704004755752362146031951465205665840079918938797056361771851047994530311215961536936283541887169156535180878864233663699607369701462321037824218572445283037132205269900255514050653933970174340553425147148993214797622395988788709572605943994223528210919230924346860415844639247799805670459, 7426988179463569301750073197586782838200202717435911385357661153208197570200804485303362695962843396307030986052311117232622043073376409347836815567322367321085387874196758434280075897513536063432730099103786733447352512984165432175254784494400699821500026196293994318206774720213317148132311223050562359314735977091536842516316149049281012797103790472349557847649282356393682360276814293256129426440381745354969522053841093229320186679875177247919985804406150542514337515002645320320069788390314900121917747534146857716743377658436154645197488134340819076585888700553005062311578963869641978771532330577371974731136, 10389979373355413148376869524987139791217158307590828693700943753512488757973725227850725013905113587408391654379552713436220790487026223039058296951420273907725324214990441639760825661323514381671141482079783647253661594138658677104054180912818864005556386671430082941396497098166887200556959866845325602873713813206312644590812141400536476615405444030140762980665885244721798105034497461675317071497925846844396796854201566038890503298824928152263774446268093725702310124363765630370263370678902342200494544961012407826314577564991676315451785987248633724138137813024481818431889574317602521878974976264742037227074]
#n=604805773885048132038788501528078428693141138274580426531445179173412328238102786863592612653315029009606622583856638282837864213048342883583286440071990592001905867027978355755042060684149344414810835371740304319571184567860694439564098306766474576403800046937218588251809179787769286393579687694925268985445059
```

`exp`

```python
from sage.all import *
from Crypto.Util.number import long_to_bytes
import re

# ç»™å®šæ•°æ®ï¼ˆæ›¿æ¢ä¸ºå®é™…é¢˜ç›®è¾“å‡ºï¼‰
random = [11250327355112956284720719987943941825496074893551827972877616718074592862130806975889275745497426515405562887727117008818863728803549848574821067056997423443681347885027000632462241968640893471352200125748453396098854283137158609264944692129301617338233670002547470932851350750870478630955328653729176440142198779254117385657086615711880537380965161180532127926250520546846863536247569437, 1289730679860726245234376434590068355673648326448223956572444944595048952808106413165882424967688302988257332835229651422892728384363094065438370663362237241013242843898967355558977974152917458085812489310623200114007728021151551927660975648884448177346441902806386690751359848832912607313329587047853601875294089502467524598036474193845319703759478494109845743765770254308199331552085163360820459311523382612948322756700518669154345145757700392164795583041949318636, 147853940073845086740348793965278392144198492906678575722238097853659884813579087132349845941828785238545905768867483183634111847434793587821166882679621234634787376562998606494582491550592596838027522285263597247798608351871499848571767008878373891341861704004755752362146031951465205665840079918938797056361771851047994530311215961536936283541887169156535180878864233663699607369701462321037824218572445283037132205269900255514050653933970174340553425147148993214797622395988788709572605943994223528210919230924346860415844639247799805670459, 7426988179463569301750073197586782838200202717435911385357661153208197570200804485303362695962843396307030986052311117232622043073376409347836815567322367321085387874196758434280075897513536063432730099103786733447352512984165432175254784494400699821500026196293994318206774720213317148132311223050562359314735977091536842516316149049281012797103790472349557847649282356393682360276814293256129426440381745354969522053841093229320186679875177247919985804406150542514337515002645320320069788390314900121917747534146857716743377658436154645197488134340819076585888700553005062311578963869641978771532330577371974731136, 10389979373355413148376869524987139791217158307590828693700943753512488757973725227850725013905113587408391654379552713436220790487026223039058296951420273907725324214990441639760825661323514381671141482079783647253661594138658677104054180912818864005556386671430082941396497098166887200556959866845325602873713813206312644590812141400536476615405444030140762980665885244721798105034497461675317071497925846844396796854201566038890503298824928152263774446268093725702310124363765630370263370678902342200494544961012407826314577564991676315451785987248633724138137813024481818431889574317602521878974976264742037227074]  # æ›¿æ¢ä¸ºé¢˜ç›®è¾“å‡ºçš„éšæœºæ•°åˆ—è¡¨ï¼ˆ5ä¸ªæ•´æ•°ï¼‰
n = 604805773885048132038788501528078428693141138274580426531445179173412328238102786863592612653315029009606622583856638282837864213048342883583286440071990592001905867027978355755042060684149344414810835371740304319571184567860694439564098306766474576403800046937218588251809179787769286393579687694925268985445059         # æ›¿æ¢ä¸ºé¢˜ç›®è¾“å‡ºçš„nå€¼

# æ­¥éª¤1ï¼šä»5ä¸ªè¿ç»­è¾“å‡ºæ¢å¤LCGå‚æ•°
r0, r1, r2, r3, r4 = random

# è®¡ç®—å·®åˆ†
d0 = r1 - r0
d1 = r2 - r1
d2 = r3 - r2
d3 = r4 - r3

# è®¡ç®—T0å’ŒT1
T0 = d0*d2 - d1**2
T1 = d1*d3 - d2**2

# è®¡ç®—gcdå¹¶å–å…¶ç»å¯¹å€¼
g = gcd(T0, T1)
g = abs(g)

# æ£€æŸ¥å¹¶æå–2048ä½çš„æ¨¡æ•°m
if g.nbits() == 2048 and g.is_prime():
    m = g
else:
    # å°è¯•ä»å› å­ä¸­æå–2048ä½çš„ç´ æ•°
    factors = factor(g)
    m_candidates = [p for p, e in factors if p.nbits() == 2048 and p.is_prime()]
    if not m_candidates:
        raise ValueError("æ— æ³•ä»gcdä¸­æå–2048ä½ç´ æ•°æ¨¡æ•°m")
    m = m_candidates[0]

# æ¢å¤å‚æ•°a
denom = r1 - r0
if denom == 0:
    raise ValueError("å·®åˆ†å€¼ä¸º0ï¼Œæ— æ³•è®¡ç®—é€†å…ƒ")
inv_denom = inverse_mod(denom, m)
a = (r2 - r1) * inv_denom % m

# æ¢å¤å‚æ•°b
b = (r1 - a * r0) % m

# æ¢å¤åˆå§‹ç§å­c
inv_a = inverse_mod(a, m)
c_seed = (r0 - b) * inv_a % m
c_val = c_seed % n  # c = 2024^{flag} mod n

F = GF(n)
base = F(2024)
target = F(c_val)

n_minus_one = n - 1

flag = discrete_log(target, base, n_minus_one)

# è½¬æ¢ä¸ºå­—èŠ‚å¹¶æå–flag
flag_bytes = long_to_bytes(int(flag))
flag_str = flag_bytes.decode('latin1')

# éªŒè¯å¹¶æ ¼å¼åŒ–UUID
match = re.search(r'H&NCTF\{(.+?)\}', flag_str)
if match:
    uuid_part = match.group(1)
    if len(uuid_part) == 36:  # UUIDæ ‡å‡†é•¿åº¦
        print("Flag:", flag_str)
    else:
        print("æå–åˆ°å¯èƒ½çš„flagï¼Œä½†UUIDæ ¼å¼å¼‚å¸¸:", flag_str)
else:
    print("æœªæ‰¾åˆ°æ ‡å‡†flagæ ¼å¼ï¼ŒåŸå§‹å­—èŠ‚:", flag_bytes)

# Flag: H&NCTF{7ecf4c8c-e6a5-45c7-b7de-2fecc31d8511}
```

## three vertical lines

`task`

```python
from Crypto.Util.number import *
from secret import flag
from rsa.prime import getprime
while(1):
    p=getprime(256)
    q=getprime(256)
    if isPrime(3*p**5+4*q**5):
        print(3*p**5+4*q**5)
        break

e = 65537
print(pow(bytes_to_long(flag), e, p * q))
#72063558451087451183203801132459543552092564094711815404066471440396765744526854383117910805713050240067432476705168314622044706081669935956972031037827580519320550326077291392722314265758802332280697884744792689996718961355845963752788234205565249205191648439412084543163083032775054018324646541875754706761793307667356964825613429368358849530455220484128264690354330356861777561511117
#2864901454060087890623075705953001126417241189889895476561381971868301515757296100356013797346138819690091860054965586977737630238293536281745826901578223
```

è¿™é¢˜å¥½å·§ä¸å·§è¢«æˆ‘åšè¿‡åŸé¢˜(niteCTF 2024 - R Stands Alone)ï¼Œä¸è¿‡é‚£é¢˜å½“æ—¶æœ‰éé¢„æœŸè§£ğŸ¤£ [é¢„æœŸè§£](https://github.com/Cryptonite-MIT/niteCTF-2024/tree/main/crypto/R%20Stands%20Alone/solution)å°±æ˜¯æŠŠæ–¹ç¨‹æ”¾åœ¨mod rä¸‹è€ƒè™‘ï¼Œä¸¤è¾¹å¼€æ ¹åç”¨æ ¼å»æ‰“ã€‚

> ä¸è¿‡å°±ç®—æ²¡åšè¿‡åŸé¢˜åº”è¯¥ä¹Ÿèƒ½æƒ³åˆ°é™æ¬¡å¤„ç†ï¼Œå¤„ç†åˆ°ä¸€æ¬¡çš„æ—¶å€™è‚¯å®šä¼šæƒ³æ ¼ä¸€æ ¼å§

`exp`

```python
from sage.all import *
from Crypto.Util.number import *
r = 72063558451087451183203801132459543552092564094711815404066471440396765744526854383117910805713050240067432476705168314622044706081669935956972031037827580519320550326077291392722314265758802332280697884744792689996718961355845963752788234205565249205191648439412084543163083032775054018324646541875754706761793307667356964825613429368358849530455220484128264690354330356861777561511117

PF = Zmod(r)
PR = PolynomialRing(PF, "x")
x = PR.gen()
c = 2864901454060087890623075705953001126417241189889895476561381971868301515757296100356013797346138819690091860054965586977737630238293536281745826901578223
assert isPrime(r)
inv = PF(-4)/PF(3)
f = x**5 - inv
print(f.roots()[0][0])
root = 28358223922809039451505880360595032492037557754419108014959801704984387395382426909907912482965374099273724433198680793561600606585076434164429817050141934114840474173780015368231251414628380474645626388950791820425221750685303585771233699046750719260223373050767626613852520861630006889754101190475520645848050199609521840203573345117528059663889417248056598901189159660274791413041928
M = Matrix(ZZ, [
    [1, root],
    [0, r]])
print(M.LLL())
p = 106939296519048296066609095791824433210081775149307042159537637081687455851889
q = 88318396054969634676003916964315749322940927962528304238128738629965788358867
phi = (p-1)*(q-1)
d = inverse(65537, phi)
print(long_to_bytes(pow(c,d,p*q)))
# b'H&NCTF{You_learned_the_code_well}'
```

# Misc
## è°åŠ¨äº†é»‘çº¿

ç»™äº†ä¸ªcsvæ–‡ä»¶ï¼Œåƒæ˜¯åŒºå—é“¾äº¤æ˜“æ—¥å¿—ä¸€ç±»çš„ä¸œè¥¿ã€‚æœ€åä¸€åˆ—æ˜¯base58ï¼Œè§£ç çœ‹å‡ºæ¥ä¸­é—´æœ‰6ä½æ—¶é—´æˆ³ï¼ŒæŒ‰è¿™ä¸ªæ—¶é—´æˆ³å‡åºæ’åˆ—åå†é€è¡Œæå–æœ€åä¸€åˆ—çš„å°å†™å­—æ¯å’Œç¬¦å·å³å¯ã€‚

ä¸æ–¹ä¾¿è´´é¢˜ç›®é™„ä»¶ï¼Œä¹Ÿå°±ä¸è´´expäº†:P 

> åæ­£æŠŠpromptå–‚ç»™AIä¹Ÿèƒ½ä¸€æŠŠæ¢­